lwar Network Protocol Specification
===================================

Message Delivery Guarantees
	Messages sent between the client and server are either ordered-reliable or unreliable. Both types 
	of messages are sent via UDP, therefore lwar's network protocol has to guarantee the in-order 
	delivery of ordered-reliable messages.

	The client and the server exchange fixed-size packets that should give reliable messages a higher 
	priority. A packet should be filled with all queued reliable messages, appending unreliable messages
	only if the maximum packet size is not exceeded. If there are any reliable messages that do not
	fit into the packet, these messages will be sent with the next packet they fit in.

	Reliable messages have a sequence number associated with them, starting at 0 and increasing by one
	with every reliable message that is sent to a specific remote peer. Reliable messages have
	to be resent for as long as the remote peer has not acknowledged the reception of the message by
	sending an ack that is equal to or greater than the message's sequence number. With every packet
	the remote peer sends, it acknowledges the maximum sequence number of all reliable message it has
	processed. The remote peer discards all reliable messages that have already been processed, and it
	only processes a reliable message that is the direct successor of the last processed reliable
	message (i.e., its sequence number is that of the last message + 1).

	The sequence numbers must be specified per message, and not per packet. If they were specified per 
	packet and a reliable message is sent twice because an acknowledgement has not been received before 
	the next packet	is sent, the client might process the same message twice, as there is no general
	way to figure out whether two reliable messages actually are the same.
	
	Unreliable messages, on the other hand, are neither acknowledged nor do the peers care if a message
	is lost. Unreliable messages are timestamped, allowing the peers to filter out older unreliable messages
	that are received after newer ones have arrived due to UDP packet reordering.

Network-related constants
	Constant						Value 			Comment
	-------------------------------	----------		---------------------------------------------------------
	Max Packet Size: 				512 bytes 		Including the packet and message headers
	Packet Header Size:			 	 12 bytes	
	Reliable Message Header Size:	  5 bytes	
	Unreliable Message Header Size:	  1 byte	
	Fixed Player Name Length: 	 	 32 bytes 		Including the trailing '\0'
	Max Chat Message Length: 		128 bytes 		Including the trailing '\0'
	Max Player Count:				  8 players
	Stats Message Frequency:		 ~2 Hz			Clients do not have to be up-to-date all the time
	Input Message Frequency:		~30	Hz			Should be relatively high to reduce latency
	Update Message Frequency:		~15 Hz			Has to balance latency and bandwidth
	Reliable Message Frequency:		~15 Hz			Has to balance latency and bandwidth
	Disconnect Timeout:				 15 seconds		Client and server consider a connection to be dropped 
													if no data has been received for the given amount of time

Packet Header
	The following data is included at the beginning of every UDP packet sent by a server or a client.
	
	Type		Name 		Description
	---------	----------	------------------------------------------------------------------------
	uint32		appId		Must always be 0xf27087c5 
	uint32		ack			Sequence number of the last reliable message that has been processed
	uint32		timestamp	Timestamp of the unreliable messages contained in the packet
	
Message Types
	The ids of reliable message types range from 1 to 99, while the ids of unreliable message types
	range from 101 to 199. This can be used to quickly determine whether a message is reliable or unreliable.

	Id		Type		Reliable	Sender			Description	
	---  	---------	---------	-------------	----------------------------------------------------------------
	  1 	Connect		yes			client			Client wants to connect to a server
	  2		Disconnect	yes			client			Client wants to disconnect from a server
	  3		Join		yes			server			Informs all clients about a new player
	  4 	Leave		yes			server			Informs all clients that a client left
	  5		Chat		yes			client/server	Broadcasts the chat message to all clients
	  6		Add			yes			server			Adds a new entity to the clients' worlds
	  7		Remove		yes			server			Removes an entity from the clients' worlds
	  8		Selection	yes			client/server	Broadcasts a ship or weapon type change to all clients
	  9		Name		yes			client/server	Broadcasts a player name change to all clients
	 10		Synced		yes			server			Signals the client that the game state has been fully synced
	 11		Full		yes			server			Signals the client that the server is full
	101		Stats		no			server			Periodically updates the clients' stats (pings, scores)
	102		Update		no			server			Periodically updates the clients' entity states
	103		Input		no			client			Periodically updates the server's client-specific input state
	
Message Header
	Both reliable and unreliable messages first contain the message type id in their header. This way, the message
	type can be read from the packet without knowing in advance whether the message is reliable or unreliable, 
	allowing for arbitrary interleaving of reliable and unreliable messages within a packet.

	Reliable messages have the following header:
	
	Type		Name 		Description
	---------	----------	------------------------------------------------------------------------
	uint8		type		One of the reliable message type ids
	uint32		seqno		The sequence number of the reliable message. Starts with 0 and increases
							by 1 with every reliable message sent to that particular remote peer.
							
	
	Unreliable messages have the following header:
	
	Type		Name 		Description
	---------	----------	------------------------------------------------------------------------
	uint8		type		One of the unreliable message type ids
	
Messages Payload Data
	Connect
		Does not carry any payload data

	Disconnect
		Does not carry any payload data
		
	Join
		Type		Name 		Description
		---------	----------	------------------------------------------------------------------------
		uint32(Id)	playerId	The generational identifier of the player that joined

	Leave
		Type		Name 		Description
		---------	----------	------------------------------------------------------------------------
		uint32(Id)	playerId	The generational identifier of the player that left
		
	Chat
		Type		Name 		Description
		---------	----------	------------------------------------------------------------------------
		uint32(Id)	playerId	The generational identifier of the player that generated the chat message
		uint8[]		message		The variable-sized, UTF8-encoded chat message, terminated by a '\0', with
								a length that does not exceed the maximum allowed chat message length
	
	Add
		Type		Name 		Description
		---------	----------	------------------------------------------------------------------------
		uint32(Id)	entityId	The generational identifier of the entity that is added
		uint32(Id)	playerId	The generational identifier of the player the entity belongs to
		uint8		typeId		The identifier of the entity type template
		
	Remove
		Type		Name 		Description
		---------	----------	------------------------------------------------------------------------
		uint32(Id)	entityId	The generational identifier of the entity that is removed
		
	Selection
		Type		Name 		Description
		---------	----------	------------------------------------------------------------------------
		uint32(Id)	playerId	The generational identifier of the player that selected a new ship or weapon
		uint8		shipType	The identifier of the new ship type template
		uint8		weaponType	The identifier of the new weapon type template
		
	Name
		Type		Name 		Description
		---------	----------	------------------------------------------------------------------------
		uint32(Id)	playerId	The generational identifier of the player that changed his/her name
		uint8[n]	name		The fixed-sized player name, terminated by a '\0', where n equals the
								exact amount of bytes allowed for a player name, including the '\0';
								UTF8-encoded

	Synced
		Does not carry any payload data
										
	Stats
		Consists of an array of values for each player, so n = Max Player Count. 
	
		Type		Name 		Description
		---------	----------	------------------------------------------------------------------------
		uint16[n]	scores		The player scores
		uint16[n]	pings		The player pings
		
	Update
		Type		Name 		Description
		---------	----------	------------------------------------------------------------------------
		uint8		num			The number of entity updates that follow
		[for i < num, ++i]
		uint32(Id)	entityId	The generational identifier of the entity that is updated
		int16		x			The new x position
		int16		y			The new y position
		int16		vx			The new x velocity
		int16		vy			The new y velocity
		uint16		rot			The new rotation
		uint8		health		The new health
		
	Input
		Type		Name 		Description
		---------	----------	------------------------------------------------------------------------	
		uint32(Id)	playerId	The generational identifier of the player that generated the message 
		uint8		forward		Boolean value
		uint8		backward	Boolean value
		uint8		left		Boolean value
		uint8		right		Boolean value
		uint8		shooting	Boolean value
	
Connecting to the server
	The client tries to establish a connection to the server by sending Connect messages to the server's
	address. The Connect message is reliable, therefore the client might send the message several times
	if it does not receive an acknowledgment from the server within a specific amount of time. If the
	client does not receive an acknowledgement before an connection timeout occurs,	it considers the server 
	to be unreachable and aborts the connection attempt. In any case, the server must discard all additional
	Connect messages it might receive from a connecting client, just as it does with any other reliable
	message that is received more than once.

	Once the server has received a Connect message from a previously unknown client, it checks whether
	it can accept an additional client or whether the server is full. In the latter case, the server
	sends a Full message back to the client. If the server is not full, it sends a Join message
	containing the id of the newly allocated player to all clients, including the new one. This must be
	the first message sent to the new client and it must have sequence number 0. Furthermore, this message
	must acknowledge the reception of the client's Connect message.

	Upon reception of the Join message, the client knows that it has established a connection to the
	server and waits for the synchronization of the game state to complete. The server starts sending
	Join messages for all active players and then sends Add messages for all active entities in the world.
	The players and entities that are sent represent the state of the server at the time the Join message
	has been sent back to the connecting client and are followed by a Synced message. After the Synced
	message has been sent, the server can start sending regular reliable and unreliable messages to 
	the new client.
	
	The Synced message is a special marker for the client, indicating that it now knows about all players 
	and	entities. The client can then wait a for a short amount of time (say, one second) until it can be
	sure that is has received Update messages for all entities. Once the client is pretty certain that it 
	has a fully synced version of the game state, it starts sending Input messages to the server,
	allowing the player to see and play the game.

Disconnecting from the server
	If the player requests a graceful disconnect from the server, the client sends a Disconnect message
	to the server. Upon reception of the message, the server stops sending any messages except for
	a Leave message with the client's player id that also acknowledges the Disconnect message. 

	The Leave message sent to a disconnecting client will not be acknowledged (similarily, a Full
	message sent to a connecting client will not be acknowledged). The server just resends the message
	until it stops receiving the Disconnect (or Connect) messages from the client. Either, the client
	received the Leave (Full) message and disconnected successfully (aborted the connection attempt)
	or the client did not receive the message and timed out. 

	If the connection between the server and the client is lost due to an unexpected event (server or 
	client crash, network cable unplugged, etc.) and cannot be reestablished within the duration of the
	Disconnect timeout, the client's game session ends and/or the server removes the client, sending all 
	of its remaining clients a Leave message for the disconnected client.

Revision History
    Rev.    Date    Author		Changes
    ----  --------  ----------	----------------------------------------------------------------------
	 2	  13-01-29	Axel		Clarified how Leave and Full messages are handled
								Re-assigned message type ids
     1    13-01-28  Axel		Initial version