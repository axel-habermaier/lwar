lwar Network Protocol Specification
===================================

Message Delivery Guarantees
	Messages sent between the client and server are either ordered-reliable or unreliable. Both types 
	of messages are sent via UDP, therefore lwar's network protocol has to guarantee the in-order 
	delivery of ordered-reliable messages.

	The client and the server exchange fixed-size packets that should give reliable messages a higher 
	priority. A packet should be filled with all queued reliable messages, appending unreliable messages
	only if the maximum packet size is not exceeded. If there are any reliable messages that do not
	fit into the packet, these messages will be sent with the next packet they fit in.

	Reliable messages have a sequence number associated with them, starting at 1 and increasing by one
	with every reliable message that is sent to a specific remote peer. Reliable messages have
	to be resent for as long as the remote peer has not acknowledged the reception of the message by
	sending an ack that is equal to or greater than the message's sequence number. With every packet
	the remote peer sends, it acknowledges the maximum sequence number of all reliable message it has
	processed. The remote peer discards all reliable messages that have already been processed, and it
	only processes a reliable message that is the direct successor of the last processed reliable
	message (i.e., its sequence number is that of the last message + 1).

	The sequence numbers must be specified per message, and not per packet. If they were specified per 
	packet and a reliable message is sent twice because an acknowledgement has not been received before 
	the next packet	is sent, the client might process the same message twice, as there is no general
	way to figure out whether two reliable messages actually are the same.
	
	Unreliable messages, on the other hand, are neither acknowledged nor do the peers care if a message
	is lost. Unreliable messages are timestamped, allowing the peers to filter out older unreliable messages
	that are received after newer ones have arrived due to UDP packet reordering.
    Hence, both peers must also discard messages that refer to obsolete (and possibly already deleted)
    players or entities.

Network-related constants
	Constant						Value 			Comment
	-------------------------------	----------		---------------------------------------------------------
	Max Packet Size: 				512 bytes 		Including the packet and message headers
	Packet Header Size:			 	 12 bytes	
	Reliable Message Header Size:	  5 bytes	
	Unreliable Message Header Size:	  1 byte	
	Max Player Name Length: 	 	 32 bytes 		
	Max Chat Message Length: 		255 bytes 		
	Max Player Count:				  8 players
	Stats Message Frequency:		 ~2 Hz			Clients do not have to be up-to-date all the time
	Input Message Frequency:		~30	Hz			Should be relatively high to reduce latency
	Update Message Frequency:		~15 Hz			Has to balance latency and bandwidth
	Reliable Message Frequency:		~15 Hz			Has to balance latency and bandwidth
	Disconnect Timeout:				 15 seconds		Client and server consider a connection to be dropped 
													if no data has been received for the given amount of time

Packet Header
	The following data is included at the beginning of every UDP packet sent by a server or a client.
	
	Type		Name 		Description
	---------	----------	------------------------------------------------------------------------
	uint32		appId		Must always be 0xf27087c5 
	uint32		ack			Sequence number of the last reliable message that has been processed
	uint32		timestamp	Timestamp of the unreliable messages contained in the packet
	
Message Types
	The ids of reliable message types range from 1 to 99, while the ids of unreliable message types
	range from 101 to 199. This can be used to quickly determine whether a message is reliable or unreliable.

	Id		Type			Reliable	Sender			Description	
	---  	---------		---------	-------------	----------------------------------------------------------------
	  1 	Connect			yes			client			Client wants to connect to a server
	  2		Disconnect		yes			client			Client wants to disconnect from a server
	  3		Join			yes			server			Informs all clients about a new player
	  4 	Leave			yes			server			Informs all clients that a client left
	  5		Chat			yes			client/server	Broadcasts the chat message to all clients
	  6		Add				yes			server			Adds a new entity to the clients' worlds
	  7		Remove			yes			server			Removes an entity from the clients' worlds
	  8		Selection		yes			client/server	Broadcasts a ship or weapon type change to all clients
	  9		Name			yes			client/server	Broadcasts a player name change to all clients
	 10		Synced			yes			server			Signals the client that the game state has been fully synced

	101		Stats			no			server			Periodically updates the clients' stats (pings, scores)
    102     (Deprecated)								(Used to be the Update message)
	103		Input			no			client			Periodically updates the server's client-specific input state
	104		Full			no			server			Signals the client that the server is full
	105		Collision		no			server			Indicates that a collision has occurred

	110		Update			no			server			Periodically updates the clients' entity states
	111		UpdatePos		no			server			Restricted updates for different kinds of entities
	112		UpdateRay		no			server			
	113		UpdateCircle	no			server			
	
Message Header
	Both reliable and unreliable messages first contain the message type id in their header. This way, the message
	type can be read from the packet without knowing in advance whether the message is reliable or unreliable, 
	allowing for arbitrary interleaving of reliable and unreliable messages within a packet.

	Reliable messages have the following header:
	
	Type		Name 		Description
	---------	----------	------------------------------------------------------------------------
	uint8		type		One of the reliable message type ids
	uint32		seqno		The sequence number of the reliable message. Starts with 0 and increases
							by 1 with every reliable message sent to that particular remote peer.
							
	
	Unreliable messages have the following header:
	
	Type		Name 		Description
	---------	----------	------------------------------------------------------------------------
	uint8		type		One of the unreliable message type ids
	
Messages Payload Data
	Connect
		Type		Name 		Description
		---------	----------	------------------------------------------------------------------------
		uint8		len			The length of the player name in bytes; len < Max Player Name Length
		uint8[len]	name		The UTF8-encoded player name (not '\0'-terminated)

	Disconnect
		Does not carry any payload data
		
	Join
		Type		Name 		Description
		---------	----------	------------------------------------------------------------------------
		uint32(Id)	playerId	The generational identifier of the player that joined
		uint8		len			The length of the player name in bytes; len < Max Player Name Length
		uint8[len]	name		The UTF8-encoded player name (not '\0'-terminated)

	Leave
		Type		Name 		Description
		---------	----------	------------------------------------------------------------------------
		uint32(Id)	playerId	The generational identifier of the player that left
		
	Chat
		Type		Name 		Description
		---------	----------	------------------------------------------------------------------------
		uint32(Id)	playerId	The generational identifier of the player that generated the chat message
		uint8		len			The length of the chat message in bytes; len < Max Chat Message Length
		uint8[len]	msg			The UTF8-encoded chat message (not '\0'-terminated)
	
	Add
		Type		Name 		Description
		---------	----------	------------------------------------------------------------------------
		uint32(Id)	entityId	The generational identifier of the entity that is added
		uint32(Id)	playerId	The generational identifier of the player the entity belongs to
		uint8		typeId		The identifier of the entity type template; the possible values are
								determined by the EntityTemplates.fsx code generation script
		
	Remove
		Type		Name 		Description
		---------	----------	------------------------------------------------------------------------
		uint32(Id)	entityId	The generational identifier of the entity that is removed
		
	Selection
		Type		Name 		Description
		---------	----------	------------------------------------------------------------------------
		uint32(Id)	playerId	The generational identifier of the player that selected a new ship or weapon
		uint8		shipType	The identifier of the new ship type template
		uint8[4]	weaponType	The identifier of the new weapon type templates for four slots
		
	Name
		Type		Name 		Description
		---------	----------	------------------------------------------------------------------------
		uint32(Id)	playerId	The generational identifier of the player that changed his/her name
		uint8		len			The length of the player name in bytes; len < Max Player Name Length
		uint8[len]	name		The UTF8-encoded player name (not '\0'-terminated)

	Synced
		Does not carry any payload data

	Full
		Does not carry any payload data
										
	Stats
		Type		Name 		Description
		---------	----------	------------------------------------------------------------------------
		uint8		num			The number of player stats updates that follow
		[for i < num, ++i]
		uint32(Id)  player		The generational identifier of the player whose stats are updated
		uint16		kills		The player kills
		uint16		deaths		The player deaths
		uint16		ping		The player pings
		
	Update
		Type		Name 		Description
		---------	----------	------------------------------------------------------------
		uint8		num			The number of entity updates that follow
		[for i < num, ++i]
		uint32(Id)	entityId	The generational identifier of the entity that is updated
		int16		x			The new x position
		int16		y			The new y position
		uint16		orientation	New orientation angle, in degrees
		uint8		health		The new health

	UpdatePos
		Type		Name 		Description
		---------	----------	------------------------------------------------------------
		uint8		num			The number of entity updates that follow
		[for i < num, ++i]
		uint32(Id)	entityId	The generational identifier of the entity that is updated
		int16		x			The new x position
		int16		y			The new y position

	UpdateRay
		Type		Name 		Description
		---------	----------	------------------------------------------------------------
		uint8		num			The number of entity updates that follow
		[for i < num, ++i]
		uint32(Id)	entityId	The generational identifier of the entity that is updated
		int16		x			The current origin x
		int16		y			The current origin y
		uint16		orientation	The orientation (direction) of the ray
		uint16		length		The lenght of the ray

	UpdateCircle
		Type		Name 		Description
		---------	----------	------------------------------------------------------------
		uint8		num			The number of entity updates that follow
		[for i < num, ++i]
		uint32(Id)	entityId	The generational identifier of the entity that is updated
		int16		x			The current center x
		int16		y			The current center y
		uint16		radius		The radius of the circle
		
	Input
		An input message contains the client's current input state, as well as the previous seven input
		states as well. This makes it less likely that a one-frame input is missed (for instance, the
		shooting button is pressed for the duration of one frame only and the corresponding packet is
		lost; in that case, no shot would be fired). For each state value, bit 0 corresponds to the
		current state, bit 1 to the previous one, bit 2 to the one before, and so on. Therefore, the
		client sets an input state with
			new = (old << 1) | (isActive ? 1 : 0)
		The server uses the message's frame number to determine whether it has missed a message and if
		so, it not only considers the current state bit, but also the bits of all missed state updates
		as well using the following code:
			state = (state & ~(0xff << (frameNo - lastFrameNo))) != 0
		That way, an input is only missed if eight consecutive packets are lost. In that case, however,
		the client has other problems anyway.

		Type		Name 		Description
		---------	----------	------------------------------------------------------------------------	
		uint32(Id)	playerId	The generational identifier of the player that generated the message 
		uint32		frameNo		The monotonically increasing frame number, starting with 1
		uint8		forward		Boolean state value, also including the seven previous states
		uint8		backward	Boolean state value, also including the seven previous states
		uint8		turnLeft	Boolean state value, also including the seven previous states
		uint8		turnRight	Boolean state value, also including the seven previous states
		uint8		strafeLeft	Boolean state value, also including the seven previous states
		uint8		strafeRight	Boolean state value, also including the seven previous states
		uint8[4]	shooting	Boolean state value, also including the seven previous states,
        						for four weapon slots
        int16		aim x		World x position of the client's aim (= mouse)
        int16		aim y		World y position of the client's aim (= mouse)

	Collision
    	Collision messages are sent for each pair of entities that collide. The order of the entityIds has
        no significance. The impact point is the point where the two entities touch.

		Type			Name 		Description
		---------		----------	------------------------------------------------------------------------
		uint32(id)[2]	entityIds 	The generational identifiers of the entities that collided
		int16			x			The x position of the impact point
		int16			y			The y position of the impact point
	
Connecting to the server
	The client tries to establish a connection to the server by sending Connect messages to the server's
	address. The Connect message is reliable, therefore the client might send the message several times
	if it does not receive an acknowledgment from the server within a specific amount of time. If the
	client does not receive an acknowledgement before an connection timeout occurs,	it considers the server 
	to be unreachable and aborts the connection attempt. In any case, the server must discard all additional
	Connect messages it might receive from a connecting client, just as it does with any other reliable
	message that is received more than once.

	Once the server has received a Connect message from a previously unknown client, it checks whether
	it can accept an additional client or whether the server is full. In the latter case, the server
	sends a Full message back to the client. If the server is not full, it sends a Join message
	containing the id of the newly allocated player to all clients, including the new one. This must be
	the first message sent to the new client and it must have sequence number 1. Furthermore, this message
	must acknowledge the reception of the client's Connect message.

	Upon reception of the Join message, the client knows that it has established a connection to the
	server and waits for the synchronization of the game state to complete. The server starts sending
	Join messages for all active players and then sends all necessary Add, Name, and Selection messages in an
	arbitrary order. The players and entities that are sent represent the state of the server at the time the 
	Join message has been sent back to the connecting client and are followed by a Synced message. After the
	Synced message has been sent, the server can start sending regular reliable and unreliable messages to 
	the new client.
	
	The Synced message is a special marker for the client, indicating that it now knows about all players 
	and	entities. The client can then wait a for a short amount of time (say, one second) until it can be
	sure that is has received Update messages for all entities. Once the client is pretty certain that it 
	has a fully synced version of the game state, it starts sending Input messages to the server,
	allowing the player to see and play the game.

Disconnecting from the server
	If the player requests a graceful disconnect from the server, the client sends a Disconnect message
	to the server. Upon reception of the message, the server stops sending any messages except for
	a Leave message with the client's player id that also acknowledges the Disconnect message. 

	The Leave message sent to a disconnecting client will not be acknowledged (similarly, a Full
	message sent to a connecting client will not be acknowledged). The server just resends the message
	until it stops receiving the Disconnect (or Connect) messages from the client. Either, the client
	received the Leave (Full) message and disconnected successfully (aborted the connection attempt)
	or the client did not receive the message and timed out. 

	If the connection between the server and the client is lost due to an unexpected event (server or 
	client crash, network cable unplugged, etc.) and cannot be reestablished within the duration of the
	Disconnect timeout, the client's game session ends and/or the server removes the client, sending all 
	of its remaining clients a Leave message for the disconnected client.

Client-side prediction
	A client may predict velocity (or acceleration) of an entity with by linear extrapolation
	with respect to time. The client may thus assume that the velocity (or acceleration) remains constant
	as long as no updates are received. Velocity can be computed as the difference of two position measures
	divided by the time interval, acceleration can similarly be obtained from velocity.
	Client-side prediction leads to a smoother display of the game, especially on bad networks.

Revision History
    Rev.    Date    Author		Changes
    ----  --------  ----------	----------------------------------------------------------------------
	14    13-06-04  Axel		Added player name to join and connect messages
	13	  13-05-31  Axel		Increased maximum allowed chat message length to 255 bytes 
	12	  15-04-12  Axel		Removed entity types; these are now determined by the F# code 
								generation script
	11	  17-02-11	Gidon		Now type-specific updates have their own message ids,
                        		four types possible so far: ships, just position, rays, circular areas.
                                Fixed selection + shooting for several slots.
	10	  13-02-11	Gidon		Added Ray, Shock Wave as entity types with id 5, 6
                        		Type-specific Update messages, client side prediction
	 9	  13-02-05	Axel		Added Rocket as entity type with id 4
     8    13-02-04  Gidon		Renamed rot to orientation, added to Input message as well
     							Initial Collision message specification
	 7	  13-01-31	Axel		Clarified what messages are sent during the game state synchronization
								phase
								The Full message is now unreliable with new id 104
	 6	  13-01-30	Gidon		Formula for input messages at the server:
								balanced parens, use "frameNo" as in packet description.
                                Added hint about obsolete ids.
	 5	  13-01-30	Axel		Changed the Input message so that lost player inputs are less likely
	 4	  13-01-30	Gidon		Sequence numbers now start with 1
	 3	  13-01-29	Axel		Stats message is no longer fix-sized
								Strings are now handled uniformly in all messages
								Added entity template ids
	 2	  13-01-29	Axel		Clarified how Leave and Full messages are handled
								Re-assigned message type ids
     1    13-01-28  Axel		Initial version
