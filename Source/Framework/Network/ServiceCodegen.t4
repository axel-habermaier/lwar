<#@ include file="../Platform/CodeModel.t4" #><# #>
<# var contract = GetServiceContract(); #>
using System;

namespace <#= Namespace #>
{
	using System.Threading.Tasks;
	using Pegasus.Framework;
	using Pegasus.Framework.Network;
	using Pegasus.Framework.Processes;

	/// <summary>
	///   Hosts a '<#= ContractName #>' service contract instance that clients can connect to in order to 
	///   remotely invoke the service operations.
	/// </summary>
	public class <#= HostName #> : ServiceHost<<#= ContractName #>>
	{
		/// <summary>
		///    Initializes a new instance that hosts the given service contract implementation.
		/// </summary>
		/// <param name="service">The implementation of the service contract that should be hosted.</param>
		public MetaServiceHost(<#= ContractName #> service)
			: base(service, new ServiceIdentifier(<#= String.Format("0x{0:X}", contract.ServiceId1) #>, <#= String.Format("0x{0:X}", contract.ServiceId2) #>))
		{
		}

		/// <summary>
		///   Deserializes the data stored in the incoming packet, invokes the operation identified by the packet and returns the
		///   result of the operation in the outgoing packet that can subsequently be sent back to the client.
		/// </summary>
		/// <param name="incomingPacket">The packet that should be used to deserialize the operation and operation arguments.</param>
		/// <param name="outgoingPacket">The packet that should contain the result of the service operation.</param>
		/// <param name="operation">Identifies the operation that the client requested.</param>
		protected override void InvokeOperation(IncomingPacket incomingPacket, OutgoingPacket outgoingPacket, int operation)
		{
			switch (operation)
			{
<# foreach (var operation in contract.Operations) { #>
				case <#= operation.OperationId #>:
				{
<# foreach (var parameter in operation.Parameters) { #>
					var <#= parameter.Name #> = incomingPacket.Read<#= parameter.TypeWithoutNamespace #>();
<# } #>
<# if (operation.ReturnsVoid) { #>
					Service.<#= operation.Name #>(<#= operation.ArgumentList #>);
<# } else { #>
					outgoingPacket.Write(Service.<#= operation.Name #>(<#= operation.ArgumentList #>));
<# } #>
					break;
				}
<# } #>
				default:
					throw new InvalidOperationException("Unknown service operation.");
			}
		}
	}

	/// <summary>
	///   Represents a proxy to a remote '<#= ContractName #>' service contract host.
	/// </summary>
	public class <#= ProxyName #> : ServiceProxy
	{
		/// <summary>
		///    Initializes a new instance.
		/// </summary>
		public  <#= ProxyName #>()
			: base(new ServiceIdentifier(<#= String.Format("0x{0:X}", contract.ServiceId1) #>, <#= String.Format("0x{0:X}", contract.ServiceId2) #>))
		{
		}
<# foreach (var operation in contract.Operations) { #>

		<#= operation.DocComment #>
		public async Task<#= operation.ReturnsVoid ? String.Empty : "<" + operation.ReturnType + ">" #> <#= operation.Name #>Async(ProcessContext context<#= operation.ParameterList.Count() == 0 ? String.Empty : ", " #><#= operation.ParameterList #>)
		{
			Assert.That(IsConnected, "The proxy is not connected to the host.");

			<#= operation.ReturnsVoid ? String.Empty : "return " #>await InvokeAsync(context, <#= operation.OperationId #>, p =>
				{
<# foreach (var parameter in operation.Parameters) { #>
					p.Write(<#= parameter.Name #>);
<# } #>
				<#= operation.ReturnsVoid ? "});" : ("}, p => p.Read" + operation.ReturnTypeWithoutNamespace + "());") #>
		}
<# } #>
	}
}

<#+

	protected string ContractName;
	protected string HostName;
	protected string ProxyName;
	protected string Namespace;

	private class ServiceContract
	{
		public string Name;
		public ulong ServiceId1;
		public ulong ServiceId2;
		public IEnumerable<ServiceOperation> Operations;
	}

	private class ServiceOperation
	{
		public string Name;
		public string ReturnType;
		public IEnumerable<Parameter> Parameters;
		public int OperationId;
		public string Comment;

		public bool ReturnsVoid
		{
			get { return String.IsNullOrEmpty(ReturnType); }
		}

		public string ParameterList
		{
			get
			{
				return String.Join(", ", Parameters.Select(p => String.Format("{0} {1}", p.Type, p.Name)));
			}
		}

		public string ArgumentList
		{
			get
			{
				return String.Join(", ", Parameters.Select(p => p.Name));
			}
		}

		public string ReturnTypeWithoutNamespace
		{
			get { return ReturnType.Substring(ReturnType.LastIndexOf(".") + 1); }
		}

		public string DocComment
		{
			get
			{
				if (Comment == "<doc>\r\n</doc>")
					return String.Empty;

				var comment = Comment.Substring(7, Comment.Length - 15);
				var lines = comment.Split(new [] { Environment.NewLine }, StringSplitOptions.None);
				var linesList = new List<string>(lines);
				linesList.Insert(3, "<param name=\"context\">The context of the process that waits for the asynchronous method to complete.</param>");
				comment = String.Join(Environment.NewLine + "\t\t", linesList.Select(l => "/// " + l));
				return comment;
			}
		}
	}

	private class Parameter
	{
		public string Name;
		public string Type;

		public string TypeWithoutNamespace
		{
			get { return Type.Substring(Type.LastIndexOf(".") + 1); }
		}
	}

	private ServiceContract GetServiceContract()
	{
		var contract = GetNamespaceElements<CodeInterface>().Where(c => c.FullName == ContractName).SingleOrDefault();
		if (contract == null)
			throw new InvalidOperationException("Definition for " + ContractName + " could not be found.");

		var serviceId = Guid.NewGuid().ToByteArray();
		return new ServiceContract 
		{ 
			Name = contract.FullName,
			ServiceId1 = ((ulong)serviceId[0]) | ((ulong)serviceId[1]) << 8 | ((ulong)serviceId[2]) << 16 | ((ulong)serviceId[3]) << 24 | 
				((ulong)serviceId[4]) << 32 | ((ulong)serviceId[5]) << 40 | ((ulong)serviceId[6]) << 48 | ((ulong)serviceId[7]) << 56,
			ServiceId2 = ((ulong)serviceId[8]) | ((ulong)serviceId[9]) << 8 | ((ulong)serviceId[10]) << 16 | ((ulong)serviceId[11]) << 24 | 
				((ulong)serviceId[12]) << 32 | ((ulong)serviceId[13]) << 40 | ((ulong)serviceId[14]) << 48 | ((ulong)serviceId[15]) << 56,
			Operations = GetOperations(contract)
		};
	}

	private IEnumerable<ServiceOperation> GetOperations(CodeInterface contract)
	{
		var methods = contract.Children.OfType<CodeFunction>();
		int operationId = 0;

		foreach (var method in methods)
		{
			yield return new ServiceOperation
			{
				Name = method.Name,
				ReturnType = method.Type.AsFullName,
				Parameters = GetParameters(method),
				OperationId = ++operationId,
				Comment = method.DocComment
			};
		}
	}

	private IEnumerable<Parameter> GetParameters(CodeFunction method)
	{
		foreach (var parameter in method.Parameters.OfType<CodeParameter>())
		{
			yield return new Parameter
			{
				Name = parameter.Name,
				Type = parameter.Type.AsFullName
			};
		}
	}

#>