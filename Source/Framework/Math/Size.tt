<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>

using System;

namespace Pegasus.Framework.Math
{
	using System.Globalization;
	using System.Runtime.InteropServices;
<# foreach (var info in GetInfo()) { #>

	/// <summary>
	///   Represents a size value with the width and height stored as <#= info.Description #> values.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public struct Size<#= info.Name #> : IEquatable<Size<#= info.Name #>>
	{
		/// <summary>
		///   The width.
		/// </summary>
		public <#= info.Type #> Width;

		/// <summary>
		///   The height.
		/// </summary>
		public <#= info.Type #> Height;

		/// <summary>
		///   Initializes a new instance.
		/// </summary>
		/// <param name="width">The width.</param>
		/// <param name="height">The height.</param>
		public Size<#= info.Name #>(<#= info.Type #> width, <#= info.Type #> height)
			: this()
		{
			Width = width;
			Height = height;
		}

		/// <summary>
		///   Determines whether the specified object is equal to this size instance.
		/// </summary>
		/// <param name="obj">The object to compare with this instance.</param>
		public override bool Equals(object obj)
		{
			if (ReferenceEquals(null, obj))
				return false;
			if (obj.GetType() != typeof(Size<#= info.Name #>))
				return false;
			return Equals((Size<#= info.Name #>)obj);
		}

		/// <summary>
		///   Determines whether the specified size instance is equal to this size instance.
		/// </summary>
		/// <param name="other">The size instance to compare with this instance.</param>
		public bool Equals(Size<#= info.Name #> other)
		{
			return <#= info.EqualsMethod("Width", "other.Width") #> && <#= info.EqualsMethod("Height", "other.Height") #>;
		}

		/// <summary>
		///   Returns a hash code for this instance.
		/// </summary>
		/// <returns>
		///   A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table.
		/// </returns>
		public override int GetHashCode()
		{
			var result = Width.GetHashCode();
			result = (result * 397) ^ Height.GetHashCode();
			return result;
		}

		/// <summary>
		///   Tests for equality between two sizes.
		/// </summary>
		/// <param name="left">The first size to compare.</param>
		/// <param name="right">The second size to compare.</param>
		public static bool operator ==(Size<#= info.Name #> left, Size<#= info.Name #> right)
		{
			return left.Equals(right);
		}

		/// <summary>
		///   Tests for inequality between two sizes.
		/// </summary>
		/// <param name="left">The first size to compare.</param>
		/// <param name="right">The second size to compare.</param>
		public static bool operator !=(Size<#= info.Name #> left, Size<#= info.Name #> right)
		{
			return !(left == right);
		}

		/// <summary>
		///   Implicitly converts a size to a vector.
		/// </summary>
		/// <param name="size">The size that should be converted.</param>
		public static implicit operator <#= info.VectorType #>(Size<#= info.Name #> size)
		{
			return new <#= info.VectorType #>(size.Width, size.Height);
		}

		/// <summary>
		///   Returns a string representation of this size instance.
		/// </summary>
		public override string ToString()
		{
			return String.Format(CultureInfo.InvariantCulture, "Width: {0}, Height: {1}", Width, Height);
		}
	}
<# } #>
}

<#+

struct Info
{
	public string Name;
	public string Type;
	public string Description;
	public string VectorType;
	public string EqualsMethodFormat;

	public string EqualsMethod(string left, string right)
	{
		return String.Format(EqualsMethodFormat, left, right);
	}
}

IEnumerable<Info> GetInfo()
{
	yield return new Info 
	{ 
		Name = "", 
		Type = "int", 
		Description = "32-bit signed integer",  
		VectorType = "Vector2i",
		EqualsMethodFormat = "{0} == {1}"
	};

	yield return new Info 
	{ 
		Name = "F", 
		Type = "float", 
		Description = "32-bit floating point", 
		VectorType = "Vector2",
		EqualsMethodFormat = "MathUtils.FloatEquality({0}, {1})" 
	};

	yield return new Info 
	{ 
		Name = "F8", 
		Type = "Fixed8", 
		Description = "32-bit signed fixed-point (in 24.8 format)", 
		VectorType = "Vector2f8",
		EqualsMethodFormat = "{0} == {1}"
	};

	yield return new Info 
	{ 
		Name = "F16", 
		Type = "Fixed16", 
		Description = "32-bit signed fixed-point (in 16.16 format)", 
		VectorType = "Vector2f16",
		EqualsMethodFormat = "{0} == {1}"
	};
}

#>