using System;

namespace Pegasus.AssetsCompiler.Effects.Compilation
{
	using System.Collections.Generic;
	using System.Linq;
	using Framework;
	using Framework.Scripting;

	/// <summary>
	///   Generates a C# class for an effect.
	/// </summary>
	internal class CSharpCodeGenerator : DisposableObject
	{
		/// <summary>
		///   The name of the method that binds the shader objects.
		/// </summary>
		private const string BindObjectsMethodName = "BindGraphicsObjects";

		/// <summary>
		///   The writer that should be used to write the generated code.
		/// </summary>
		private readonly CodeWriter _writer = new CodeWriter();

		/// <summary>
		///   The effect for which the C# class should be generated.
		/// </summary>
		private EffectClass _effect;

		/// <summary>
		///   Initializes a new instance.
		/// </summary>
		public CSharpCodeGenerator()
		{
			_writer.AppendLine("//------------------------------------------------------------------------------");
			_writer.AppendLine("// <auto-generated>");
			_writer.AppendLine("//     Generated by Pegasus Asset Compiler, version {0}.{1}", Cvars.AppVersionMajor.Value,
							   Cvars.AppVersionMinor.Value);
			_writer.AppendLine("//     {0}, {1}", DateTime.Now.ToLongDateString(), DateTime.Now.ToLongTimeString());
			_writer.AppendLine("//");
			_writer.AppendLine("//     Changes to this file may cause incorrect behavior and will be lost if");
			_writer.AppendLine("//     the code is regenerated.");
			_writer.AppendLine("// </auto-generated>");
			_writer.AppendLine("//------------------------------------------------------------------------------");
			_writer.Newline();
			_writer.AppendLine("using System;");
			_writer.AppendLine("using System.Runtime.InteropServices;");
			_writer.AppendLine("using Pegasus.Framework;");
			_writer.AppendLine("using Pegasus.Framework.Math;");
			_writer.AppendLine("using Pegasus.Framework.Platform.Graphics;");
			_writer.Newline();
		}

		/// <summary>
		///   Gets all non-shared constant buffers declared by the effect.
		/// </summary>
		private IEnumerable<ConstantBuffer> ConstantBuffers
		{
			get
			{
				return from buffer in _effect.ConstantBuffers
					   where !buffer.Shared
					   select buffer;
			}
		}

		/// <summary>
		///   Gets all non-shared constants declared by the effect.
		/// </summary>
		private IEnumerable<ShaderConstant> Constants
		{
			get
			{
				return from buffer in ConstantBuffers
					   from constant in buffer.Constants
					   select constant;
			}
		}

		/// <summary>
		///   Generates the C# effect code.
		/// </summary>
		/// <param name="effect">The effect for which the C# code should be generated.</param>
		public void GenerateCode(EffectClass effect)
		{
			Assert.ArgumentNotNull(effect, () => effect);
			_effect = effect;

			_writer.AppendLine("namespace {0}", _effect.Namespace);
			_writer.AppendBlockStatement(() =>
				{
					_writer.AppendLine("public sealed class {0}", _effect.Name);
					_writer.AppendBlockStatement(GenerateClass);
				});

			_writer.Newline();
		}

		/// <summary>
		///   Generates the C# class for the effect.
		/// </summary>
		private void GenerateClass()
		{
			GenerateDirtyFields();
			GenerateConstantBufferFields();
			GenerateConstantsFields();

			GenerateConstructor();

			GenerateConstantsProperties();
			GenerateTextureProperties();

			GenerateObjectBindingMethod();

			GenerateConstantBufferStructs();
		}

		/// <summary>
		///   Generates the dirty fields for all non-shared constant buffers declared by the effect.
		/// </summary>
		private void GenerateDirtyFields()
		{
			foreach (var buffer in ConstantBuffers)
				_writer.AppendLine("private bool _dirty{0} = true;", buffer.Name);

			if (ConstantBuffers.Any())
				_writer.Newline();
		}

		/// <summary>
		///   Generates the fields for the non-shared constant buffers declared by the effect.
		/// </summary>
		private void GenerateConstantBufferFields()
		{
			foreach (var buffer in ConstantBuffers)
				_writer.AppendLine("private readonly ConstantBuffer _{0};", Decapitalize(buffer.Name));

			if (ConstantBuffers.Any())
				_writer.Newline();
		}

		/// <summary>
		///   Generates the fields for all non-shared constants declared by the effect.
		/// </summary>
		private void GenerateConstantsFields()
		{
			foreach (var constant in Constants)
				_writer.AppendLine("private {0} _{1};", ToCSharpType(constant.Type), Decapitalize(constant.Name));

			if (Constants.Any())
				_writer.Newline();
		}

		/// <summary>
		/// Generates the constructor.
		/// </summary>
		private void GenerateConstructor()
		{
			_writer.AppendLine("public {0}(GraphicsDevice graphicsDevice)", _effect.Name);
			_writer.AppendBlockStatement(() =>
				{
					foreach (var buffer in ConstantBuffers)
						_writer.AppendLine("_{0} = new ConstantBuffer(graphicsDevice, {1});", Decapitalize(buffer.Name), buffer.Size);
				});
			_writer.Newline();
		}

		/// <summary>
		///   Generates the properties for all non-shared constants declared by the effect.
		/// </summary>
		private void GenerateConstantsProperties()
		{
			foreach (var buffer in ConstantBuffers)
			{
				foreach (var constant in buffer.Constants)
				{
					_writer.AppendLine("public {0} {1}", ToCSharpType(constant.Type), constant.Name);
					_writer.AppendBlockStatement(() =>
						{
							_writer.AppendLine("get {{ return _{0}; }}", Decapitalize(constant.Name));
							_writer.AppendLine("set");
							_writer.AppendBlockStatement(() =>
								{
									_writer.AppendLine("_{0} = value;", Decapitalize(constant.Name));
									_writer.AppendLine("_dirty{0} = true;", buffer.Name);
								});
						});
					_writer.Newline();
				}
			}
		}

		/// <summary>
		///   Generates the properties for the shader texture objects declared by the effect.
		/// </summary>
		private void GenerateTextureProperties()
		{
			foreach (var texture in _effect.Textures)
				_writer.AppendLine("public {0} {1} {{ get; set; }}", ToCSharpType(texture.Type), texture.Name);

			if (_effect.Textures.Any())
				_writer.Newline();
		}

		/// <summary>
		///   Generates the state binding method.
		/// </summary>
		private void GenerateObjectBindingMethod()
		{
			_writer.AppendLine("private unsafe void {0}()", BindObjectsMethodName);
			_writer.AppendBlockStatement(() =>
				{
					foreach (var texture in _effect.Textures)
					{
						_writer.AppendLine("Assert.NotNull({0}, \"Texture object '{0}' has not been set.\");", texture.Name);
						_writer.AppendLine("{0}.Bind({1});", texture.Name, texture.Slot);
					}

					if (_effect.Textures.Any() && ConstantBuffers.Any())
						_writer.Newline();

					foreach (var buffer in ConstantBuffers)
					{
						_writer.AppendLine("if (_dirty{0})", buffer.Name);
						_writer.AppendBlockStatement(() =>
							{
								_writer.AppendLine("{0} data = new {0}();", buffer.Name);
								foreach (var constant in buffer.Constants)
									_writer.AppendLine("data.{0} = {0};", constant.Name);

								_writer.Newline();
								_writer.AppendLine("_dirty{0} = false;", buffer.Name);
								_writer.AppendLine("_{0}.CopyData(&data);", Decapitalize(buffer.Name));
							});
						_writer.Newline();
					}

					foreach (var buffer in ConstantBuffers)
						_writer.AppendLine("_{0}.Bind({1});", Decapitalize(buffer.Name), buffer.Slot);
				});

			if (ConstantBuffers.Any())
			_writer.Newline();
		}

		/// <summary>
		///   Generates the structures for the non-shared constant buffers declared by the effect.
		/// </summary>
		private void GenerateConstantBufferStructs()
		{
			foreach (var buffer in _effect.ConstantBuffers.Where(buffer => !buffer.Shared))
			{
				_writer.AppendLine("[StructLayout(LayoutKind.Sequential, Size = {0})]", buffer.Size);
				_writer.AppendLine("private struct {0}", buffer.Name);
				_writer.AppendBlockStatement(() =>
					{
						foreach (var constant in buffer.Constants)
							_writer.AppendLine("public {0} {1};", ToCSharpType(constant.Type), constant.Name);
					});
			}
		}

		/// <summary>
		///   Gets the corresponding C# type.
		/// </summary>
		/// <param name="dataType">The data type that should be converted.</param>
		private static string ToCSharpType(DataType dataType)
		{
			switch (dataType)
			{
				case DataType.Boolean:
					return "bool";
				case DataType.Integer:
					return "int";
				case DataType.Float:
					return "float";
				case DataType.Vector2:
					return "Vector2";
				case DataType.Vector3:
					return "Vector3";
				case DataType.Vector4:
					return "Vector4";
				case DataType.Matrix:
					return "Matrix";
				case DataType.Texture2D:
					return "Texture2D";
				case DataType.CubeMap:
					return "CubeMap";
				default:
					throw new NotSupportedException("Unsupported data type.");
			}
		}

		/// <summary>
		///   Decapitalizes the first letter of the given string.
		/// </summary>
		/// <param name="value">The string that should be decapitalized.</param>
		private static string Decapitalize(string value)
		{
			Assert.ArgumentNotNullOrWhitespace(value, () => value);
			return Char.ToLower(value[0]) + value.Substring(1);
		}

		/// <summary>
		///   Disposes the object, releasing all managed and unmanaged resources.
		/// </summary>
		protected override void OnDisposing()
		{
			_writer.WriteToFile(Configuration.CSharpEffectFile);
		}
	}
}