using System;

namespace Pegasus.AssetsCompiler.Effects.Compilation
{
	using System.Collections.Generic;
	using System.Linq;
	using Framework;

	/// <summary>
	///   Generates a C# class for an effect.
	/// </summary>
	internal class CSharpCodeGenerator : DisposableObject
	{
		/// <summary>
		///   The name of the method that binds the constant buffers and textures.
		/// </summary>
		private const string Bind = "Bind";

		/// <summary>
		///   The writer that should be used to write the generated code.
		/// </summary>
		private readonly CodeWriter _writer = new CodeWriter();

		/// <summary>
		///   The effect for which the C# class should be generated.
		/// </summary>
		private EffectClass _effect;

		/// <summary>
		///   The path of the C# effect file that declared the effect.
		/// </summary>
		private string _path;

		/// <summary>
		///   Initializes a new instance.
		/// </summary>
		public CSharpCodeGenerator()
		{
			_writer.AppendLine("//------------------------------------------------------------------------------");
			_writer.AppendLine("// <auto-generated>");
			_writer.AppendLine("//     Generated by the Pegasus Asset Compiler.");
			_writer.AppendLine("//     {0}, {1}", DateTime.Now.ToLongDateString(), DateTime.Now.ToLongTimeString());
			_writer.AppendLine("//");
			_writer.AppendLine("//     Changes to this file may cause incorrect behavior and will be lost if");
			_writer.AppendLine("//     the code is regenerated.");
			_writer.AppendLine("// </auto-generated>");
			_writer.AppendLine("//------------------------------------------------------------------------------");
			_writer.Newline();
			_writer.AppendLine("using System;");
			_writer.AppendLine("using System.Runtime.InteropServices;");
			_writer.AppendLine("using Pegasus.Framework;");
			_writer.AppendLine("using Pegasus.Framework.Math;");
			_writer.AppendLine("using Pegasus.Framework.Platform.Assets;");
			_writer.AppendLine("using Pegasus.Framework.Platform.Graphics;");
			_writer.Newline();
		}

		/// <summary>
		///   Gets all non-shared constant buffers declared by the effect.
		/// </summary>
		private IEnumerable<ConstantBuffer> ConstantBuffers
		{
			get
			{
				return from buffer in _effect.ConstantBuffers
					   where !buffer.Shared
					   select buffer;
			}
		}

		/// <summary>
		///   Gets all non-shared constants declared by the effect.
		/// </summary>
		private IEnumerable<ShaderConstant> Constants
		{
			get
			{
				return from buffer in ConstantBuffers
					   from constant in buffer.Constants
					   select constant;
			}
		}

		/// <summary>
		///   Generates the C# effect code.
		/// </summary>
		/// <param name="effect">The effect for which the C# code should be generated.</param>
		/// <param name="path">The path of the C# effect file that declared the effect.</param>
		public void GenerateCode(EffectClass effect, string path)
		{
			Assert.ArgumentNotNull(effect, () => effect);
			Assert.ArgumentNotNullOrWhitespace(path, () => path);

			_effect = effect;
			_path = path;

			_writer.AppendLine("namespace {0}", _effect.Namespace);
			_writer.AppendBlockStatement(() =>
				{
					_writer.AppendLine("public sealed class {0} : Effect", _effect.Name);
					_writer.AppendBlockStatement(GenerateClass);
				});

			_writer.Newline();
		}

		/// <summary>
		///   Generates the C# class for the effect.
		/// </summary>
		private void GenerateClass()
		{
			GenerateDirtyFields();
			GenerateConstantBufferFields();
			GenerateConstantsFields();
			GenerateShaderFields();

			GenerateConstructor();

			GenerateConstantsProperties();
			GenerateTextureProperties();

			GenerateObjectBindingMethod();

			GenerateConstantBufferStructs();
		}

		/// <summary>
		///   Generates the dirty fields for all non-shared constant buffers declared by the effect.
		/// </summary>
		private void GenerateDirtyFields()
		{
			foreach (var buffer in ConstantBuffers)
				_writer.AppendLine("private bool {0} = true;", GetDirtyFlagName(buffer.Name));

			if (ConstantBuffers.Any())
				_writer.Newline();
		}

		/// <summary>
		///   Generates the fields for the non-shared constant buffers declared by the effect.
		/// </summary>
		private void GenerateConstantBufferFields()
		{
			foreach (var buffer in ConstantBuffers)
				_writer.AppendLine("private readonly ConstantBuffer {0};", GetFieldName(buffer.Name));

			if (ConstantBuffers.Any())
				_writer.Newline();
		}

		/// <summary>
		///   Generates the fields for all non-shared constants declared by the effect.
		/// </summary>
		private void GenerateConstantsFields()
		{
			foreach (var constant in Constants)
				_writer.AppendLine("private {0} {1};", ToCSharpType(constant.Type), GetFieldName(constant.Name));

			if (Constants.Any())
				_writer.Newline();
		}

		/// <summary>
		///   Generates the fields for all shaders declared by the effect.
		/// </summary>
		private void GenerateShaderFields()
		{
			foreach (var shader in _effect.Shaders)
				_writer.AppendLine("private readonly {0} {1};", shader.Type, GetFieldName(shader.Name));

			_writer.Newline();
		}

		/// <summary>
		///   Generates the constructor.
		/// </summary>
		private void GenerateConstructor()
		{
			_writer.AppendLine("public {0}(GraphicsDevice graphicsDevice, AssetsManager assets)", _effect.Name);
			_writer.AppendBlockStatement(() =>
				{
					_writer.AppendLine("Assert.ArgumentNotNull(graphicsDevice, () => graphicsDevice);");
					_writer.AppendLine("Assert.ArgumentNotNull(assets, () => assets);");
					_writer.Newline();

					foreach (var shader in _effect.Shaders)
					{
						_writer.AppendLine("{0} = Load{1}(assets, \"{2}/{3}.{4}\");", GetFieldName(shader.Name), shader.Type, _path,
										   _effect.FullName, shader.Name);
					}

					if (ConstantBuffers.Any())
						_writer.Newline();

					foreach (var buffer in ConstantBuffers)
						_writer.AppendLine("{0} = CreateConstantBuffer(graphicsDevice, {1}, {2});", GetFieldName(buffer.Name), buffer.Size,
										   buffer.Slot);
				});
			_writer.Newline();
		}

		/// <summary>
		///   Generates the properties for all non-shared constants declared by the effect.
		/// </summary>
		private void GenerateConstantsProperties()
		{
			foreach (var buffer in ConstantBuffers)
			{
				foreach (var constant in buffer.Constants)
				{
					_writer.AppendLine("public {0} {1}", ToCSharpType(constant.Type), constant.Name);
					_writer.AppendBlockStatement(() =>
						{
							_writer.AppendLine("get {{ return {0}; }}", GetFieldName(constant.Name));
							_writer.AppendLine("set");
							_writer.AppendBlockStatement(() =>
								{
									_writer.AppendLine("{0} = value;", GetFieldName(constant.Name));
									_writer.AppendLine("{0} = true;", GetDirtyFlagName(buffer.Name));
								});
						});
					_writer.Newline();
				}
			}
		}

		/// <summary>
		///   Generates the properties for the shader texture objects declared by the effect.
		/// </summary>
		private void GenerateTextureProperties()
		{
			foreach (var texture in _effect.Textures)
				_writer.AppendLine("public TextureBinding<{0}> {1} {{ get; set; }}", ToCSharpType(texture.Type), texture.Name);

			if (_effect.Textures.Any())
				_writer.Newline();
		}

		/// <summary>
		///   Generates the state binding method.
		/// </summary>
		private void GenerateObjectBindingMethod()
		{
			_writer.Append("private ");
			if (Constants.Any())
				_writer.Append("unsafe ");
			
			_writer.AppendLine("void {0}()", Bind);
			_writer.AppendBlockStatement(() =>
				{
					foreach (var buffer in ConstantBuffers)
					{
						_writer.AppendLine("if ({0})", GetDirtyFlagName(buffer.Name));
						_writer.AppendBlockStatement(() =>
							{
								_writer.AppendLine("{0} data = new {0}();", buffer.Name);
								foreach (var constant in buffer.Constants)
									_writer.AppendLine("data.{0} = {0};", constant.Name);

								_writer.Newline();
								_writer.AppendLine("{0} = false;", GetDirtyFlagName(buffer.Name));
								_writer.AppendLine("Update({0}, &data);", GetFieldName(buffer.Name));
							});
						_writer.Newline();
					}

					foreach (var texture in _effect.Textures)
						_writer.AppendLine("Bind({0}, {1});", texture.Name, texture.Slot);

					foreach (var buffer in ConstantBuffers)
						_writer.AppendLine("Bind({0});", GetFieldName(buffer.Name));
				});

			if (ConstantBuffers.Any())
				_writer.Newline();
		}

		/// <summary>
		///   Generates the structures for the non-shared constant buffers declared by the effect.
		/// </summary>
		private void GenerateConstantBufferStructs()
		{
			foreach (var buffer in _effect.ConstantBuffers.Where(buffer => !buffer.Shared))
			{
				_writer.AppendLine("[StructLayout(LayoutKind.Sequential, Size = {0})]", buffer.Size);
				_writer.AppendLine("private struct {0}", buffer.Name);
				_writer.AppendBlockStatement(() =>
					{
						foreach (var constant in buffer.Constants)
							_writer.AppendLine("public {0} {1};", ToCSharpType(constant.Type), constant.Name);
					});
			}
		}

		/// <summary>
		///   Gets the corresponding C# type.
		/// </summary>
		/// <param name="dataType">The data type that should be converted.</param>
		private static string ToCSharpType(DataType dataType)
		{
			switch (dataType)
			{
				case DataType.Boolean:
					return "bool";
				case DataType.Integer:
					return "int";
				case DataType.Float:
					return "float";
				case DataType.Vector2:
					return "Vector2";
				case DataType.Vector3:
					return "Vector3";
				case DataType.Vector4:
					return "Vector4";
				case DataType.Matrix:
					return "Matrix";
				case DataType.Texture2D:
					return "Texture2D";
				case DataType.CubeMap:
					return "CubeMap";
				default:
					throw new NotSupportedException("Unsupported data type.");
			}
		}

		/// <summary>
		///   Decapitalizes the first letter of the given string.
		/// </summary>
		/// <param name="value">The string that should be decapitalized.</param>
		private static string Decapitalize(string value)
		{
			Assert.ArgumentNotNullOrWhitespace(value, () => value);
			return Char.ToLower(value[0]) + value.Substring(1);
		}

		/// <summary>
		///   Disposes the object, releasing all managed and unmanaged resources.
		/// </summary>
		protected override void OnDisposing()
		{
			_writer.WriteToFile(Configuration.CSharpEffectFile);
		}

		/// <summary>
		///   Gets the name of the corresponding field.
		/// </summary>
		/// <param name="name">The name whose field name should be returned.</param>
		private static string GetFieldName(string name)
		{
			return String.Format("_{0}", Decapitalize(name));
		}

		/// <summary>
		///   Gets the name of the corresponding dirty flag.
		/// </summary>
		/// <param name="name">The name whose dirty flag name should be returned.</param>
		private static string GetDirtyFlagName(string name)
		{
			return String.Format("_dirty{0}", name);
		}
	}
}