<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
using System;

namespace Pegasus.Math
{
	using System.Globalization;
	using System.Runtime.InteropServices;
<# foreach (var info in GetInfo()) { #>

	/// <summary>
	///     Represents a rectangle with the left, top, width, and height stored as <#= info.Description #> values.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public struct Rectangle<#= info.Name #> : IEquatable<Rectangle<#= info.Name #>>
	{
		/// <summary>
		///     Represents a rectangle at the origin with an area of 0.
		/// </summary>
		public static readonly Rectangle<#= info.Name #> Empty;

		/// <summary>
		///     The X-coordinate of the left edge of the rectangle.
		/// </summary>
		public <#= info.Type #> Left;

		/// <summary>
		///     The Y-coordinate of the top edge of the rectangle.
		/// </summary>
		public <#= info.Type #> Top;

		/// <summary>
		///     The width of the rectangle.
		/// </summary>
		public <#= info.Type #> Width;

		/// <summary>
		///     The height of the rectangle.
		/// </summary>
		public <#= info.Type #> Height;

		/// <summary>
		///     Initializes a new instance.
		/// </summary>
		/// <param name="left">The X-coordinate of the left edge of the rectangle.</param>
		/// <param name="top">The Y-coordinate of the left edge of the rectangle.</param>
		/// <param name="width">The width of the rectangle.</param>
		/// <param name="height">The height of the rectangle.</param>
		public Rectangle<#= info.Name #>(<#= info.Type #> left, <#= info.Type #> top, <#= info.Type #> width, <#= info.Type #> height)
		{
			Left = left;
			Top = top;
			Width = width;
			Height = height;
		}

		/// <summary>
		///     Initializes a new instance.
		/// </summary>
		/// <param name="position">The position of the rectangle's top left corner.</param>
		/// <param name="width">The width of the rectangle.</param>
		/// <param name="height">The height of the rectangle.</param>
		public Rectangle<#= info.Name #>(<#= info.PositionType #> position, <#= info.Type #> width, <#= info.Type #> height)
		{
			Left = position.X;
			Top = position.Y;
			Width = width;
			Height = height;
		}

		/// <summary>
		///     Initializes a new instance.
		/// </summary>
		/// <param name="left">The X-coordinate of the left edge of the rectangle.</param>
		/// <param name="top">The Y-coordinate of the left edge of the rectangle.</param>
		/// <param name="size">The size of the rectangle.</param>
		public Rectangle<#= info.Name #>(<#= info.Type #> left, <#= info.Type #> top, <#= info.SizeType #> size)
		{
			Left = left;
			Top = top;
			Width = size.Width;
			Height = size.Height;
		}

		/// <summary>
		///     Initializes a new instance.
		/// </summary>
		/// <param name="position">The position of the rectangle's top left corner.</param>
		/// <param name="size">The size of the rectangle.</param>
		public Rectangle<#= info.Name #>(<#= info.PositionType #> position, <#= info.SizeType #> size)
		{
			Left = position.X;
			Top = position.Y;
			Width = size.Width;
			Height = size.Height;
		}

		/// <summary>
		///     Gets the X-coordinate of the right edge of the rectangle.
		/// </summary>
		public <#= info.Type #> Right
		{
			get { return Left + Width; }
		}

		/// <summary>
		///     Gets the Y-coordinate of the bottom edge of the rectangle.
		/// </summary>
		public <#= info.Type #> Bottom
		{
			get { return Top + Height; }
		}

		/// <summary>
		///     Gets the position of the rectangle's top left corner.
		/// </summary>
		public <#= info.PositionType #> Position
		{
			get { return new <#= info.PositionType #>(Left, Top); }
		}

		/// <summary>
		///     Gets the size of the rectangle.
		/// </summary>
		public <#= info.SizeType #> Size
		{
			get { return new <#= info.SizeType #>(Width, Height); }
		}

		/// <summary>
		///     Gets the position of the rectangle's top left corner.
		/// </summary>
		public <#= info.PositionType #> TopLeft
		{
			get { return Position; }
		}

		/// <summary>
		///     Gets the position of the rectangle's top right corner.
		/// </summary>
		public <#= info.PositionType #> TopRight
		{
			get { return Position + new <#= info.PositionType #>(Width, 0); }
		}

		/// <summary>
		///     Gets the position of the rectangle's bottom left corner.
		/// </summary>
		public <#= info.PositionType #> BottomLeft
		{
			get { return Position + new <#= info.PositionType #>(0, Height); }
		}

		/// <summary>
		///     Gets the position of the rectangle's bottom right corner.
		/// </summary>
		public <#= info.PositionType #> BottomRight
		{
			get { return Position + new <#= info.PositionType #>(Width, Height); }
		}

		/// <summary>
		///     Returns a copy of the rectangle with the given offsets added to the position of the returned rectangle.
		/// </summary>
		/// <param name="x">The offset that should be applied to the rectangle's left edge.</param>
		/// <param name="y">The offset that should be applied to the rectangle's top edge.</param>
		public Rectangle<#= info.Name #> Offset(<#= info.Type #> x, <#= info.Type #> y)
		{
			return new Rectangle<#= info.Name #>(Left + x, Top + y, Width, Height);
		}

		/// <summary>
		///     Returns a copy of the rectangle with the given offsets added to the position of the returned rectangle.
		/// </summary>
		/// <param name="offset">The offset that should be applied to the rectangle's position.</param>
		public Rectangle<#= info.Name #> Offset(<#= info.PositionType #> offset)
		{
			return Offset(offset.X, offset.Y);
		}

		/// <summary>
		///     Returns an enlarged copy of the rectangle. The returned rectangle has a width and a height that is enlarged 
		///     by the given amount in both directions, and the rectangle is moved by the given amount in the (left, up) direction.
		/// </summary>
		/// <param name="amount">The amount that the rectangle should be enlarged in both X and Y directions.</param>
		public Rectangle<#= info.Name #> Enlarge(<#= info.Type #> amount)
		{
			return Enlarge(amount, amount);
		}

		/// <summary>
		///     Returns an enlarged copy of the rectangle. The returned rectangle has a width and a height that is enlarged 
		///     by the given amount in both directions, and the rectangle is moved by the given amounts in the (left, up) direction.
		/// </summary>
		/// <param name="amount">The amount that the rectangle should be enlarged in both X and Y directions.</param>
		public Rectangle<#= info.Name #> Enlarge(<#= info.PositionType #> amount)
		{
			return Enlarge(amount.X, amount.Y);
		}

		/// <summary>
		///     Returns an enlarged copy of the rectangle. The returned rectangle has a width and a height that is enlarged 
		///     by the given amount in both directions, and the rectangle is moved by the given amounts in the (left, up) direction.
		/// </summary>
		/// <param name="x">The amount that the rectangle should be enlarged in X-direction.</param>
		/// <param name="y">The amount that the rectangle should be enlarged in Y-direction.</param>
		public Rectangle<#= info.Name #> Enlarge(<#= info.Type #> x, <#= info.Type #> y)
		{
			return new Rectangle<#= info.Name #>(Left - x, Top - y, Width + 2 * x, Height + 2 * y);
		}

		/// <summary>
		///     Determines whether the given rectangle is equal to this rectangle.
		/// </summary>
		/// <param name="other">The other rectangle to compare with this rectangle.</param>
		public bool Equals(Rectangle<#= info.Name #> other)
		{
			return <#= info.EqualsMethod("Left", "other.Left") #> && <#= info.EqualsMethod("Top", "other.Top") #> && 
				<#= info.EqualsMethod("Width", "other.Width") #> && <#= info.EqualsMethod("Height", "other.Height") #>;
		}

		/// <summary>
		///     Determines whether the specified object is equal to this rectangle.
		/// </summary>
		/// <param name="value">The object to compare with this rectangle.</param>
		public override bool Equals(object value)
		{
			if (ReferenceEquals(null, value))
				return false;

			if (value.GetType() != typeof(Rectangle<#= info.Name #>))
				return false;

			return Equals((Rectangle<#= info.Name #>)value);
		}

		/// <summary>
		///     Returns a hash code for this rectangle.
		/// </summary>
		public override int GetHashCode()
		{
			var result = Left.GetHashCode();
			result = (result * 397) ^ Top.GetHashCode();
			result = (result * 397) ^ Width.GetHashCode();
			result = (result * 397) ^ Height.GetHashCode();
			return result;
		}

		/// <summary>
		///     Tests for equality between two rectangles.
		/// </summary>
		/// <param name="left">The first rectangle to compare.</param>
		/// <param name="right">The second rectangle to compare.</param>
		public static bool operator ==(Rectangle<#= info.Name #> left, Rectangle<#= info.Name #> right)
		{
			return left.Equals(right);
		}

		/// <summary>
		///     Tests for inequality between two rectangles.
		/// </summary>
		/// <param name="left">The first rectangle to compare.</param>
		/// <param name="right">The second rectangle to compare.</param>
		public static bool operator !=(Rectangle<#= info.Name #> left, Rectangle<#= info.Name #> right)
		{
			return !(left == right);
		}

		/// <summary>
		///     Returns a string representation of this rectangle.
		/// </summary>
		public override string ToString()
		{
			return String.Format(CultureInfo.InvariantCulture, "Left: {0}, Top: {1}, Width: {2}, Height: {3}", Left, Top, Width, Height);
		}

		/// <summary>
		///     Checks whether this rectangle intersects with the given rectangle.
		/// </summary>
		/// <param name="rectangle">The rectangle that should be checked.</param>
		public bool Intersects(Rectangle<#= info.Name #> rectangle)
		{
			var xOverlap = (Left >= rectangle.Left && Left <= rectangle.Right) ||
				(rectangle.Left >= Left && rectangle.Left <= Right);

			var yOverlap = (Top >= rectangle.Top && Top <= rectangle.Bottom) ||
				(rectangle.Top >= Top && rectangle.Top <= Bottom);

			return xOverlap && yOverlap;
		}

		/// <summary>
		///     Checks whether this rectangle intersects with the given circle.
		/// </summary>
		/// <param name="circle">The circle that should be checked.</param>
		public bool Intersects(<#= info.CircleType #> circle)
		{
			return circle.Intersects(this);
		}

		/// <summary>
		///     Checks whether the given point lies within the rectangle.
		/// </summary>
		/// <param name="point">The point that should be checked.</param>
		public bool Intersects(<#= info.PositionType #> point)
		{
			return point.X >= Left && point.X <= Right && point.Y >= Top && point.Y <= Bottom;
		}
	}
<# } #>
}

<#+

struct Info
{
	public string Name;
	public string Type;
	public string Description;
	public string PositionType;
	public string SizeType;
	public string CircleType;
	public string EqualsMethodFormat;

	public string EqualsMethod(string left, string right)
	{
		return String.Format(EqualsMethodFormat, left, right);
	}
}

IEnumerable<Info> GetInfo()
{
	yield return new Info 
	{ 
		Name = "", 
		Type = "int", 
		Description = "32-bit signed integer",  
		PositionType = "Vector2i",
		SizeType = "Size",
		CircleType = "Circle",
		EqualsMethodFormat = "{0} == {1}"
	};

	yield return new Info 
	{ 
		Name = "F", 
		Type = "float", 
		Description = "32-bit floating point", 
		PositionType = "Vector2",
		SizeType = "SizeF",
		CircleType = "CircleF",
		EqualsMethodFormat = "MathUtils.Equals({0}, {1})" 
	};

	yield return new Info 
	{ 
		Name = "D", 
		Type = "double", 
		Description = "64-bit floating point", 
		PositionType = "Vector2d",
		SizeType = "SizeD",
		CircleType = "CircleD",
		EqualsMethodFormat = "MathUtils.Equals({0}, {1})" 
	};

	yield return new Info 
	{ 
		Name = "F8", 
		Type = "Fixed8", 
		Description = "32-bit signed fixed-point (in 24.8 format)", 
		PositionType = "Vector2f8",
		SizeType = "SizeF8",
		CircleType = "CircleF8",
		EqualsMethodFormat = "{0} == {1}"
	};

	yield return new Info 
	{ 
		Name = "F16", 
		Type = "Fixed16", 
		Description = "32-bit signed fixed-point (in 16.16 format)", 
		PositionType = "Vector2f16",
		SizeType = "SizeF16",
		CircleType = "CircleF16",
		EqualsMethodFormat = "{0} == {1}"
	};
}

#>