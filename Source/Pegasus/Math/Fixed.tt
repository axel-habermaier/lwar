<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ import namespace="System" #>
<#@ output extension=".cs" #>
using System;

namespace Pegasus.Math
{
	using System.Globalization;
<# foreach (var fractionalBits in new int[] { 8, 16 }) { #>

	/// <summary>
	///   Represents a 32-bit signed fixed-point value, with <#= fractionalBits #> bits being used for the fractional part of the value.
	/// </summary>
	public struct Fixed<#= fractionalBits #> : IEquatable<Fixed<#= fractionalBits #>>, IComparable<Fixed<#= fractionalBits #>>, IComparable
	{
		/// <summary>
		///   The number of bits that are used to store the fractional part of the value.
		/// </summary>
		private const int FractionalBits = <#= fractionalBits #>;

		/// <summary>
		///   Epsilon value for fixed-point equality comparisons.
		/// </summary>
		public static readonly Fixed<#= fractionalBits #> Epsilon = MathUtils.Epsilon;

		/// <summary>
		///   Represents a 180 degree rotation or the ratio of the circumference of a circle to its diameter.
		/// </summary>
		public static readonly Fixed<#= fractionalBits #> Pi = System.Math.PI;

		/// <summary>
		///   Represents a 360 degree rotation.
		/// </summary>
		public static readonly Fixed<#= fractionalBits #> TwoPi = System.Math.PI * 2;

		/// <summary>
		///   Represents the value of Pi divided by two, i.e., a 90 dregree rotation.
		/// </summary>
		public static readonly Fixed<#= fractionalBits #> PiOver2 = System.Math.PI / 2;

		/// <summary>
		///   Represents the largest possible value of the integer part of a fixed-point value.
		/// </summary>
		public const int MaxValue = Int32.MaxValue >> FractionalBits;

		/// <summary>
		///   Represents the smallest possible value of the integer part of a fixed-point value.
		/// </summary>
		public const int MinValue = Int32.MinValue >> FractionalBits;

		/// <summary>
		///   The raw value stored as a 32-bit signed integer.
		/// </summary>
		private int _rawValue;

		/// <summary>
		///   Initializes a new instance.
		/// </summary>
		/// <param name="value">The integer value that should be converted.</param>
		public Fixed<#= fractionalBits #>(int value)
		{
			Assert.ArgumentInRange(value, MinValue, MaxValue);
			_rawValue = value << FractionalBits;
		}

		/// <summary>
		///   Initializes a new instance.
		/// </summary>
		/// <param name="value">The floating-point value that should be converted.</param>
		public Fixed<#= fractionalBits #>(float value)
		{
			Assert.ArgumentInRange(value, MinValue, MaxValue);
			_rawValue = (int)System.Math.Round(value * (1 << FractionalBits));
		}

		/// <summary>
		///   Initializes a new instance.
		/// </summary>
		/// <param name="value">The floating-point value that should be converted.</param>
		public Fixed<#= fractionalBits #>(double value)
		{
			Assert.ArgumentInRange(value, MinValue, MaxValue);
			_rawValue = (int)System.Math.Round(value * (1 << FractionalBits));
		}

		/// <summary>
		///   Gets or sets the raw value stored as a 32-bit signed integer.
		/// </summary>
		public int RawValue
		{
			get { return _rawValue; }
			set { _rawValue = value; }
		}

		/// <summary>
		///   Returns the fully qualified type name of this instance.
		/// </summary>
		public override string ToString()
		{
			return ((float)this).ToString(CultureInfo.InvariantCulture);
		}

		#region Cast operators

		/// <summary>
		///   Implicitely casts an integer value to its fixed-point representation.
		/// </summary>
		/// <param name="value">The integer value that should be converted.</param>
		public static implicit operator Fixed<#= fractionalBits #>(int value)
		{
			return new Fixed<#= fractionalBits #>(value);
		}

		/// <summary>
		///   Implicitely casts a fixed-point value to its integer representation.
		/// </summary>
		/// <param name="value">The fixed-point value that should be converted.</param>
		public static explicit operator int(Fixed<#= fractionalBits #> value)
		{
			return value._rawValue >> FractionalBits;
		}

		/// <summary>
		///   Implicitely casts an floating-point value to its fixed-point representation.
		/// </summary>
		/// <param name="value">The floating-point value that should be converted.</param>
		public static implicit operator Fixed<#= fractionalBits #>(float value)
		{
			return new Fixed<#= fractionalBits #>(value);
		}

		/// <summary>
		///   Implicitely casts a fixed-point value to its floating-point representation.
		/// </summary>
		/// <param name="value">The fixed-point value that should be converted.</param>
		public static explicit operator float(Fixed<#= fractionalBits #> value)
		{
			return value._rawValue / (float)(1 << FractionalBits);
		}

		/// <summary>
		///   Implicitely casts an floating-point value to its fixed-point representation.
		/// </summary>
		/// <param name="value">The floating-point value that should be converted.</param>
		public static implicit operator Fixed<#= fractionalBits #>(double value)
		{
			return new Fixed<#= fractionalBits #>(value);
		}

		/// <summary>
		///   Implicitely casts a fixed-point value to its floating-point representation.
		/// </summary>
		/// <param name="value">The fixed-point value that should be converted.</param>
		public static explicit operator double(Fixed<#= fractionalBits #> value)
		{
			return value._rawValue / (double)(1 << FractionalBits);
		}

		#endregion

		#region Equality operators and comparison

		/// <summary>
		///   Indicates whether the current fixed-point value is equal to another fixed-point value.
		/// </summary>
		/// <param name="other">The value to compare with this value.</param>
		public bool Equals(Fixed<#= fractionalBits #> other)
		{
			return _rawValue == other._rawValue;
		}

		/// <summary>
		///   Indicates whether the current fixed-point value is equal to another object.
		/// </summary>
		/// <param name="obj">An object to compare with this value.</param>
		public override bool Equals(object obj)
		{
			if (ReferenceEquals(null, obj))
				return false;
			return obj is Fixed<#= fractionalBits #> && Equals((Fixed<#= fractionalBits #>)obj);
		}

		/// <summary>
		///   Returns the hash code for this instance.
		/// </summary>
		public override int GetHashCode()
		{
			return _rawValue;
		}

		/// <summary>
		///   Compares the current value with the given one.
		/// </summary>
		/// <param name="other">The value this instance should be compared with.</param>
		public int CompareTo(object other)
		{
			if (other == null) 
				return 1;

			Assert.ArgumentSatisfies(other is Fixed<#= fractionalBits #>, "The given object is not of type 'Fixed<#= fractionalBits #>'.");
			return CompareTo((Fixed<#= fractionalBits #>)other);
		}

		/// <summary>
		///   Compares the current value with the given one.
		/// </summary>
		/// <param name="other">The value this instance should be compared with.</param>
		public int CompareTo(Fixed<#= fractionalBits #> other)
		{
			return _rawValue.CompareTo(other._rawValue);
		}

		/// <summary>
		///   Tests for equality between two fixed-point values.
		/// </summary>
		/// <param name="left">The first fixed-point value to compare.</param>
		/// <param name="right">The second fixed-point value to compare.</param>
		public static bool operator ==(Fixed<#= fractionalBits #> left, Fixed<#= fractionalBits #> right)
		{
			return left.Equals(right);
		}

		/// <summary>
		///   Tests for inequality between two fixed-point values.
		/// </summary>
		/// <param name="left">The first fixed-point value to compare.</param>
		/// <param name="right">The second fixed-point value to compare.</param>
		public static bool operator !=(Fixed<#= fractionalBits #> left, Fixed<#= fractionalBits #> right)
		{
			return !left.Equals(right);
		}

		#endregion

		#region Arithmetic operators

		/// <summary>
		///   Adds the two fixed-point values and returns the result.
		/// </summary>
		/// <param name="left">The first fixed-point operand.</param>
		/// <param name="right">The second fixed-point operand.</param>
		public static Fixed<#= fractionalBits #> operator +(Fixed<#= fractionalBits #> left, Fixed<#= fractionalBits #> right)
		{
			return new Fixed<#= fractionalBits #> { _rawValue = left._rawValue + right._rawValue };
		}

		/// <summary>
		///   Subtracts the two fixed-point values and returns the result.
		/// </summary>
		/// <param name="left">The first fixed-point operand.</param>
		/// <param name="right">The second fixed-point operand.</param>
		public static Fixed<#= fractionalBits #> operator -(Fixed<#= fractionalBits #> left, Fixed<#= fractionalBits #> right)
		{
			return new Fixed<#= fractionalBits #> { _rawValue = left._rawValue - right._rawValue };
		}

		/// <summary>
		///   Negates the fixed-point value.
		/// </summary>
		/// <param name="value">The value that should be negated.</param>
		public static Fixed<#= fractionalBits #> operator -(Fixed<#= fractionalBits #> value)
		{
			return new Fixed<#= fractionalBits #> { _rawValue = -value._rawValue };
		}

		/// <summary>
		///   Multiplies the two fixed-point values and returns the result.
		/// </summary>
		/// <param name="left">The first fixed-point operand.</param>
		/// <param name="right">The second fixed-point operand.</param>
		public static Fixed<#= fractionalBits #> operator *(Fixed<#= fractionalBits #> left, Fixed<#= fractionalBits #> right)
		{
			long leftValue = left._rawValue;
			long rightValue = right._rawValue;
			var value = (leftValue * rightValue) >> FractionalBits;

			Assert.InRange(value, ((long)MinValue) << FractionalBits, ((long)MaxValue) << FractionalBits);
			return new Fixed<#= fractionalBits #> { _rawValue = (int)value };
		}

		/// <summary>
		///   Multiplies the fixed-point value and the integer value and returns the result.
		/// </summary>
		/// <param name="left">The fixed-point operand.</param>
		/// <param name="right">The integer operand.</param>
		public static Fixed<#= fractionalBits #> operator *(Fixed<#= fractionalBits #> left, int right)
		{
			return new Fixed<#= fractionalBits #> { _rawValue = left._rawValue * right };
		}

		/// <summary>
		///   Multiplies the fixed-point value and the integer value and returns the result.
		/// </summary>
		/// <param name="left">The integer operand.</param>
		/// <param name="right">The fixed-point operand.</param>
		public static Fixed<#= fractionalBits #> operator *(int left, Fixed<#= fractionalBits #> right)
		{
			return new Fixed<#= fractionalBits #> { _rawValue = left * right._rawValue };
		}

		/// <summary>
		///   Divides the two fixed-point values and returns the result.
		/// </summary>
		/// <param name="left">The first fixed-point operand.</param>
		/// <param name="right">The second fixed-point operand.</param>
		public static Fixed<#= fractionalBits #> operator /(Fixed<#= fractionalBits #> left, Fixed<#= fractionalBits #> right)
		{
			var leftValue = ((long)left._rawValue) << FractionalBits;
			var value = (leftValue / right._rawValue);

			return new Fixed<#= fractionalBits #> { _rawValue = (int)value };
		}

		#endregion

		#region Relational operators

		/// <summary>
		///   Indicates whether the first fixed-point value is smaller than the second one.
		/// </summary>
		/// <param name="left">The first fixed-point operand.</param>
		/// <param name="right">The second fixed-point operand.</param>
		public static bool operator <(Fixed<#= fractionalBits #> left, Fixed<#= fractionalBits #> right)
		{
			return left._rawValue < right._rawValue;
		}

		/// <summary>
		///   Indicates whether the first fixed-point value is smaller than the second one.
		/// </summary>
		/// <param name="left">The first fixed-point operand.</param>
		/// <param name="right">The second fixed-point operand.</param>
		public static bool operator >(Fixed<#= fractionalBits #> left, Fixed<#= fractionalBits #> right)
		{
			return left._rawValue > right._rawValue;
		}

		/// <summary>
		///   Indicates whether the first fixed-point value is smaller than or equal to the second one.
		/// </summary>
		/// <param name="left">The first fixed-point operand.</param>
		/// <param name="right">The second fixed-point operand.</param>
		public static bool operator <=(Fixed<#= fractionalBits #> left, Fixed<#= fractionalBits #> right)
		{
			return left._rawValue <= right._rawValue;
		}

		/// <summary>
		///   Indicates whether the first fixed-point value is smaller than or equal to the second one.
		/// </summary>
		/// <param name="left">The first fixed-point operand.</param>
		/// <param name="right">The second fixed-point operand.</param>
		public static bool operator >=(Fixed<#= fractionalBits #> left, Fixed<#= fractionalBits #> right)
		{
			return left._rawValue >= right._rawValue;
		}

		#endregion

		#region Functions

		/// <summary>
		/// Returns the absolute value of a fixed-point value.
		/// </summary>
		/// <param name="value">The value whose absolute should be returned.</param>
		public static Fixed<#= fractionalBits #> Abs(Fixed<#= fractionalBits #> value)
		{
			if (value < 0)
				return value * -1;

			return value;
		}

		/// <summary>
		///   Computes the square root of the given fixed-point value.
		/// </summary>
		/// <param name="value">The value for which the square root should be computed.</param>
		public static Fixed<#= fractionalBits #> Sqrt(Fixed<#= fractionalBits #> value)
		{
			Assert.ArgumentSatisfies(value._rawValue >= 0, "Value must be greater than 0.");

			if (value == 0)
				return 0;

			// Normalize to range 1 < n <= 4
			int normalizationCount = 0;
			while (true)
			{
				if (value < 1)
				{
					--normalizationCount;
					value *= 4;
				}
				else if (value > 4)
				{
					++normalizationCount;
					value /= 4;
				}
				else
					break;
			}

			// Initial approximation
			var x = (value + 1) / 2;

			// Heron's recurrence equation
			x = (x + value / x) / 2;
			x = (x + value / x) / 2;
			x = (x + value / x) / 2;
			x = (x + value / x) / 2;
			x = (x + value / x) / 2;
			x = (x + value / x) / 2;

			// Denormalize again
			for (var i = 0; i < normalizationCount; ++i)
				x *= 2;

			for (var i = 0; i < -normalizationCount; ++i)
				x /= 2;

			return x;
		}

		#endregion
	}
<# } #>
}