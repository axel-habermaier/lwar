<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
// ReSharper disable InconsistentNaming
using System;

namespace Pegasus.Math
{
	using System.Globalization;
	using System.Runtime.InteropServices;
<# foreach (var info in GetInfo()) { #>

	/// <summary>
	///     Represents a two-component vector of <#= info.Description #> values.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public struct Vector2<#= info.Name #> : IEquatable<Vector2<#= info.Name #>>
	{
		/// <summary>
		///     A vector with all components set to zero.
		/// </summary>
		public static readonly Vector2<#= info.Name #> Zero = new Vector2<#= info.Name #>(0, 0);

		/// <summary>
		///     The X-component of the vector.
		/// </summary>
		public <#= info.Type #> X;

		/// <summary>
		///     The Y-component of the vector.
		/// </summary>
		public <#= info.Type #> Y;

		/// <summary>
		///     Initializes a new instance.
		/// </summary>
		/// <param name="x">The X-component of the vector.</param>
		/// <param name="y">The Y-component of the vector.</param>
		public Vector2<#= info.Name #>(<#= info.Type #> x, <#= info.Type #> y)
		{
			X = x;
			Y = y;
		}

		/// <summary>
		///     Gets the length of the vector.
		/// </summary>
		public <#= info.LengthType #> Length
		{
			get { return <#= info.Sqrt #>(SquaredLength); }
		}

		/// <summary>
		///     Gets the squared length of the vector.
		/// </summary>
		public <#= info.Type #> SquaredLength
		{
			get { return X * X + Y * Y; }
		}

		/// <summary>
		///     Constructs a new vector instance that is normalized to a length of 1, but still points into the same direction.
		/// </summary>
		public Vector2<#= info.NormalizedType #> Normalize()
		{
			var length = Length;
			if (length < <#= info.Epsilon #>)
				length = <#= info.Epsilon #>;

			return new Vector2<#= info.NormalizedType #>(X / length, Y / length);
		}

		/// <summary>
		///     Determines whether the given vector is equal to this vector.
		/// </summary>
		/// <param name="other">The other vector to compare with this vector.</param>
		public bool Equals(Vector2<#= info.Name #> other)
		{
			return <#= info.EqualsMethod("X", "other.X") #> && <#= info.EqualsMethod("Y", "other.Y") #>;
		}

		/// <summary>
		///     Determines whether the specified object is equal to this vector.
		/// </summary>
		/// <param name="value">The object to compare with this vector.</param>
		public override bool Equals(object value)
		{
			if (value == null)
				return false;

			if (!ReferenceEquals(value.GetType(), typeof(Vector2<#= info.Name #>)))
				return false;

			return Equals((Vector2<#= info.Name #>)value);
		}

		/// <summary>
		///     Returns a hash code for this vector.
		/// </summary>
		public override int GetHashCode()
		{
			return (X.GetHashCode() * 397) ^ Y.GetHashCode();
		}

		/// <summary>
		///     Returns a string representation of this vector.
		/// </summary>
		public override string ToString()
		{
			return String.Format(CultureInfo.InvariantCulture, "X: {0}, Y: {1}", X, Y);
		}

		/// <summary>
		///     Tests for equality between two vectors.
		/// </summary>
		/// <param name="left">The first vector to compare.</param>
		/// <param name="right">The second vector to compare.</param>
		public static bool operator ==(Vector2<#= info.Name #> left, Vector2<#= info.Name #> right)
		{
			return left.Equals(right);
		}

		/// <summary>
		///     Tests for inequality between two vectors.
		/// </summary>
		/// <param name="left">The first vector to compare.</param>
		/// <param name="right">The second vector to compare.</param>
		public static bool operator !=(Vector2<#= info.Name #> left, Vector2<#= info.Name #> right)
		{
			return !(left == right);
		}

		/// <summary>
		///     Performs a vector addition.
		/// </summary>
		/// <param name="left">The first vector to add.</param>
		/// <param name="right">The second vector to add.</param>
		public static Vector2<#= info.Name #> operator +(Vector2<#= info.Name #> left, Vector2<#= info.Name #> right)
		{
			return new Vector2<#= info.Name #>(left.X + right.X, left.Y + right.Y);
		}

		/// <summary>
		///     Negates the components of a vector.
		/// </summary>
		/// <param name="vector">The vector whose components should be negated.</param>
		public static Vector2<#= info.Name #> operator -(Vector2<#= info.Name #> vector)
		{
			return new Vector2<#= info.Name #>(-vector.X, -vector.Y);
		}

		/// <summary>
		///     Performs a vector subtraction.
		/// </summary>
		/// <param name="left">The first vector.</param>
		/// <param name="right">The second vector.</param>
		public static Vector2<#= info.Name #> operator -(Vector2<#= info.Name #> left, Vector2<#= info.Name #> right)
		{
			return new Vector2<#= info.Name #>(left.X - right.X, left.Y - right.Y);
		}

		/// <summary>
		///     Scales the vector by the given factor.
		/// </summary>
		/// <param name="vector">The vector that should be scaled.</param>
		/// <param name="factor">The factor that should be applied.</param>
		public static Vector2<#= info.Name #> operator *(Vector2<#= info.Name #> vector, <#= info.Type #> factor)
		{
			return new Vector2<#= info.Name #>(vector.X * factor, vector.Y * factor);
		}

		/// <summary>
		///     Scales the vector by the given factor.
		/// </summary>
		/// <param name="factor">The factor that should be applied.</param>
		/// <param name="vector">The vector that should be scaled.</param>
		public static Vector2<#= info.Name #> operator *(<#= info.Type #> factor, Vector2<#= info.Name #> vector)
		{
			return new Vector2<#= info.Name #>(factor * vector.X, factor * vector.Y);
		}

		/// <summary>
		///     Divides the vector by a scalar value.
		/// </summary>
		/// <param name="vector">The vector that should be divided.</param>
		/// <param name="factor">The scalar value the vector should be divided by.</param>
		public static Vector2<#= info.Name #> operator /(Vector2<#= info.Name #> vector, <#= info.Type #> factor)
		{
			return new Vector2<#= info.Name #>(vector.X / factor, vector.Y / factor);
		}

		/// <summary>
		///     Computes the dot product of the two vectors.
		/// </summary>
		/// <param name="left">The first vector.</param>
		/// <param name="right">The second vector.</param>
		public static <#= info.Type #> Dot(Vector2<#= info.Name #> left, Vector2<#= info.Name #> right)
		{
			return left.X * right.X + left.Y * right.Y;
		}
<# if (info.Type == "float") { #>

		/// <summary>
		///     Applies the given transformation matrix to the vector.
		/// </summary>
		/// <param name="vector">The vector that should be transformed.</param>
		/// <param name="matrix">The transformation matrix that should be applied.</param>
		public static Vector2 Transform(ref Vector2 vector, ref Matrix matrix)
		{
			var vector4 = new Vector4(vector.X, vector.Y, 0);
			vector4 = Vector4.Transform(ref vector4, ref matrix);
			return new Vector2(vector4.X, vector4.Y);
		}
<# } #>
	}
<# } #>
}

// ReSharper restore InconsistentNaming

<#+

struct Info
{
	public string Name;
	public string Type;
	public string Description;
	public string Sqrt;
	public string LengthType;
	public string NormalizedType;
	public string Epsilon;
	public string EqualsMethodFormat;

	public string EqualsMethod(string left, string right)
	{
		return String.Format(EqualsMethodFormat, left, right);
	}
}

IEnumerable<Info> GetInfo()
{
	yield return new Info 
	{ 
		Name = "", 
		Type = "float",
		Description = "32-bit floating point", 
		Sqrt = "(float)System.Math.Sqrt",
		LengthType = "float",
		Epsilon = "MathUtils.Epsilon",
		NormalizedType = "",
		EqualsMethodFormat = "MathUtils.Equals({0}, {1})"
	};

	yield return new Info 
	{ 
		Name = "d", 
		Type = "double",
		Description = "64-bit floating point", 
		Sqrt = "System.Math.Sqrt",
		LengthType = "double",
		Epsilon = "MathUtils.Epsilon",
		NormalizedType = "d",
		EqualsMethodFormat = "MathUtils.Equals({0}, {1})"
	};

	yield return new Info 
	{ 
		Name = "i", 
		Type = "int", 
		Description = "32-bit signed integer",
		Sqrt = "Fixed16.Sqrt",
		LengthType = "Fixed16",
		Epsilon = "Fixed16.Epsilon",
		NormalizedType = "f16",
		EqualsMethodFormat = "{0} == {1}"
	};

	yield return new Info 
	{ 
		Name = "f8",
		Type = "Fixed8", 
		Description = "32-bit signed fixed-point (in 24.8 format)",
		Sqrt = "Fixed8.Sqrt",
		LengthType = "Fixed8",
		Epsilon = "Fixed8.Epsilon",
		NormalizedType = "f8",
		EqualsMethodFormat = "{0} == {1}"
	};

	yield return new Info 
	{
		Name = "f16", 
		Type = "Fixed16", 
		Description = "32-bit signed fixed-point (in 16.16 format)",
		Sqrt = "Fixed16.Sqrt",
		LengthType = "Fixed16",
		Epsilon = "Fixed16.Epsilon",
		NormalizedType = "f16",
		EqualsMethodFormat = "{0} == {1}"
	};
}

#>