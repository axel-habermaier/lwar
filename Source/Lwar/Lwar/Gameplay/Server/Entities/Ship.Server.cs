namespace Lwar.Gameplay.Server.Entities
{
	using System;
	using Behaviors;
	using Network;
	using Pegasus.Math;
	using Templates;

	public partial class Ship
	{
		/// <summary>
		///     The current acceleration of the ship's propulsion system.
		/// </summary>
		private Vector2 _acceleration;

		/// <summary>
		///     The current velocity generated by the ship's propulsion system.
		/// </summary>
		private Vector2 _propulsionVelocity;

		/// <summary>
		///     The remaining amount of time in seconds before the warp drive energy is starting to recharge.
		/// </summary>
		private float _remainingRechargeDelay;

		/// <summary>
		///     The remaining amount in seconds to wait before the warp drive can be activated again.
		/// </summary>
		private float _remainingWarpCooldown;

		/// <summary>
		///     The current rotational velocity of the ship.
		/// </summary>
		private float _rotationVelocity;

		/// <summary>
		///     The current state of the warp drive.
		/// </summary>
		private WarpDriveState _warpDriveState;

		/// <summary>
		///     Gets a value indicating whether the warp drive is currently enabled.
		/// </summary>
		private bool WarpDriveEnabled
		{
			get { return _warpDriveState == WarpDriveState.Active; }
		}

		/// <summary>
		///     Invoked when the server-side entity is added to a game session.
		/// </summary>
		/// <remarks>Hides the method from deriving types.</remarks>
		public override void OnServerAdded()
		{
			for (var i = 0; i < NetworkProtocol.WeaponSlotCount; ++i)
			{
				switch (Player.WeaponTypes[i])
				{
					case EntityType.Gun:
					{
						var behavior = GunBehavior.Create(GameSession.Allocator);
						Weapons[i] = Weapon.Create(GameSession, this, WeaponTemplate.Gun, Player, behavior);
						break;
					}
					case EntityType.Phaser:
					{
						var behavior = PhaserBehavior.Create(GameSession.Allocator);
						Weapons[i] = Weapon.Create(GameSession, this, WeaponTemplate.Phaser, Player, behavior);
						break;
					}
					default:
						throw new InvalidOperationException("Unsupported weapon type.");
				}
			}
		}

		/// <summary>
		///     Invoked when the server-side entity is removed from a game session.
		/// </summary>
		/// <remarks>This method is not called when the game session is disposed.</remarks>
		/// <remarks>Hides the method from deriving types.</remarks>
		public override void OnServerRemoved()
		{
			for (var i = 0; i < NetworkProtocol.WeaponSlotCount; ++i)
				Weapons[i] = null;
		}

		/// <summary>
		///     Handles the given player input.
		/// </summary>
		/// <param name="target">The target the ship should be facing, relative to the ship's position.</param>
		/// <param name="forward">Indicates whether the ship should move forward.</param>
		/// <param name="backward">Indicates whether the ship should move backward.</param>
		/// <param name="strafeLeft">Indicates whether the ship should strafe to the left.</param>
		/// <param name="strafeRight">Indicates whether the ship should strafe to the right.</param>
		/// <param name="warp">Indicates whether the ship should enable its warp drive.</param>
		/// <param name="fireWeapons">Indicates which weapons should be fired.</param>
		public void HandlePlayerInput(Vector2 target, bool forward, bool backward, bool strafeLeft, bool strafeRight,
									  bool warp, bool[] fireWeapons)
		{
			// Update the warp drive state
			var canEnableWarpDrive = WarpDriveEnergy > Template.WarpDrive.ActivationEnergy && _remainingWarpCooldown <= 0;
			var warpDriveEnabled = warp && WarpDriveEnergy > 0 && (WarpDriveEnabled || canEnableWarpDrive);
			_warpDriveState = warpDriveEnabled ? WarpDriveState.Active : WarpDriveState.WaitingForRecharging;

			// Update weapons; in warp mode, firing is impossible
			for (var i = 0; i < NetworkProtocol.WeaponSlotCount; ++i)
				Weapons[i].HandlePlayerInput(fireWeapons[i] && !WarpDriveEnabled);

			// Compute the angular velocity, considering the target orientation.
			// We always use the shortest path to rotate towards the target.
			var targetOrientation = Vector2.ToAngle(target);
			var orientationDelta = targetOrientation - Orientation;
			orientationDelta = MathUtils.Atan2(MathUtils.Sin(orientationDelta), MathUtils.Cos(orientationDelta));
			_rotationVelocity = Template.MaxRotationSpeed * orientationDelta;

			// Update the acceleration of the entity
			var acceleration = Vector2.Zero;

			// When the warp drive is active an while we're dropping out of warp, always move forward
			if (WarpDriveEnabled)
				acceleration = new Vector2(1, 0);
			else if (_propulsionVelocity.Length <= Template.MaxSpeed * 1.2f)
			{
				if (forward)
					acceleration += new Vector2(1, 0);
				if (backward)
					acceleration += new Vector2(-1, 0);
				if (strafeLeft)
					acceleration += new Vector2(0, -1);
				if (strafeRight)
					acceleration += new Vector2(0, 1);
			}

			_acceleration = Vector2.Rotate(acceleration, Orientation).Normalize();
		}

		/// <summary>
		///     Updates the entity when the entity is used by a server.
		/// </summary>
		/// <param name="elapsedSeconds">The number of seconds that have elapsed since the last update.</param>
		public override void ServerUpdate(float elapsedSeconds)
		{
			UpdateWarpDriveState(elapsedSeconds);

			var maxSpeed = WarpDriveEnabled ? Template.WarpDrive.MaxSpeed : Template.MaxSpeed;
			var acceleration = _acceleration;

			// If we're dropping out of warp, decelerate quickly; otherwise, when the player doesn't want
			// the ship to move, slowly come to a halt
			if (_propulsionVelocity.Length > maxSpeed)
				acceleration -= _propulsionVelocity.Normalize() * Template.WarpDrive.Drag;
			else
				acceleration -= _propulsionVelocity.Normalize() * Template.Drag;

			var velocityDelta = acceleration * Template.MaxAcceleration * elapsedSeconds;
			_propulsionVelocity += velocityDelta;

			Velocity += velocityDelta;
			Position2D += Velocity * elapsedSeconds;
			Orientation += _rotationVelocity * elapsedSeconds;
		}

		/// <summary>
		///     Updates the state of the ship's warp drive.
		/// </summary>
		/// <param name="elapsedSeconds">The number of seconds that have elapsed since the last update.</param>
		private void UpdateWarpDriveState(float elapsedSeconds)
		{
			switch (_warpDriveState)
			{
				case WarpDriveState.FullyCharged:
					break;
				case WarpDriveState.Recharging:
					WarpDriveEnergy += Template.WarpDrive.RechargeSpeed * elapsedSeconds;
					if (WarpDriveEnergy > Template.WarpDrive.MaxEnergy)
						_warpDriveState = WarpDriveState.FullyCharged;
					break;
				case WarpDriveState.Active:
					_remainingWarpCooldown = Template.WarpDrive.Cooldown;
					_remainingRechargeDelay = Template.WarpDrive.RechargeDelay;
					WarpDriveEnergy -= Template.WarpDrive.DepleteSpeed * elapsedSeconds;
					if (WarpDriveEnergy < 0)
						_warpDriveState = WarpDriveState.WaitingForRecharging;
					break;
				case WarpDriveState.WaitingForRecharging:
					_remainingRechargeDelay -= elapsedSeconds;
					if (_remainingRechargeDelay < 0)
						_warpDriveState = WarpDriveState.Recharging;
					break;
				default:
					throw new InvalidOperationException("Unknown warp drive state.");
			}

			_remainingWarpCooldown -= elapsedSeconds;
			WarpDriveEnergy = MathUtils.Clamp(WarpDriveEnergy, 0, Template.WarpDrive.MaxEnergy);
		}

		/// <summary>
		///     Describes the state of the warp drive.
		/// </summary>
		private enum WarpDriveState
		{
			/// <summary>
			///     Indicates that the warp drive is fully charged and can be activated.
			/// </summary>
			FullyCharged,

			/// <summary>
			///     Indicates that the warp drive is inactive and recharging. It can only be activated if the minimum required energy
			///     level has been recharged.
			/// </summary>
			Recharging,

			/// <summary>
			///     Indicates that the warp drive is currently active.
			/// </summary>
			Active,

			/// <summary>
			///     Indicates that the warp drive is inactive and waiting to be recharged once the recharge delay has passed.
			/// </summary>
			WaitingForRecharging
		}
	}
}