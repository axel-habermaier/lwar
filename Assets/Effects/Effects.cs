//------------------------------------------------------------------------------
// <auto-generated>
//     Generated by the Pegasus Asset Compiler.
//     Monday, 01 April 2013, 17:35:08
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Runtime.InteropServices;
using Pegasus.Framework;
using Pegasus.Framework.Math;
using Pegasus.Framework.Platform.Assets;
using Pegasus.Framework.Platform.Graphics;

namespace Lwar.Assets.Effects
{
	public sealed class BlurEffect : Effect
	{
		private readonly VertexShader _vertexShader;
		private readonly FragmentShader _horizontalBlur;
		private readonly FragmentShader _verticalBlur;

		public BlurEffect(GraphicsDevice graphicsDevice, AssetsManager assets)
		{
			Assert.ArgumentNotNull(graphicsDevice, () => graphicsDevice);
			Assert.ArgumentNotNull(assets, () => assets);

			_vertexShader = LoadVertexShader(assets, "Effects/Lwar.Assets.Effects.BlurEffect.VertexShader");
			_horizontalBlur = LoadFragmentShader(assets, "Effects/Lwar.Assets.Effects.BlurEffect.HorizontalBlur");
			_verticalBlur = LoadFragmentShader(assets, "Effects/Lwar.Assets.Effects.BlurEffect.VerticalBlur");
		}

		public TextureBinding<Texture2D> Texture { get; set; }

		private void Bind()
		{
			Bind(Texture, 0);
		}
	}
}

namespace Lwar.Assets.Effects
{
	public sealed class SkyboxEffect : Effect
	{
		private readonly VertexShader _vertexShader;
		private readonly FragmentShader _fragmentShader;

		public SkyboxEffect(GraphicsDevice graphicsDevice, AssetsManager assets)
		{
			Assert.ArgumentNotNull(graphicsDevice, () => graphicsDevice);
			Assert.ArgumentNotNull(assets, () => assets);

			_vertexShader = LoadVertexShader(assets, "Effects/Lwar.Assets.Effects.SkyboxEffect.VertexShader");
			_fragmentShader = LoadFragmentShader(assets, "Effects/Lwar.Assets.Effects.SkyboxEffect.FragmentShader");
		}

		public TextureBinding<CubeMap> Skybox { get; set; }

		private void Bind()
		{
			Bind(Skybox, 0);
		}
	}
}

namespace Lwar.Assets.Effects
{
	public sealed class SphereEffect : Effect
	{
		private bool _dirtyConstantBuffer2 = true;

		private readonly ConstantBuffer _constantBuffer2;

		private Matrix _world;

		private readonly VertexShader _vertexShader;
		private readonly FragmentShader _fragmentShader;

		public SphereEffect(GraphicsDevice graphicsDevice, AssetsManager assets)
		{
			Assert.ArgumentNotNull(graphicsDevice, () => graphicsDevice);
			Assert.ArgumentNotNull(assets, () => assets);

			_vertexShader = LoadVertexShader(assets, "Effects/Lwar.Assets.Effects.SphereEffect.VertexShader");
			_fragmentShader = LoadFragmentShader(assets, "Effects/Lwar.Assets.Effects.SphereEffect.FragmentShader");

			_constantBuffer2 = CreateConstantBuffer(graphicsDevice, 64, 2);
		}

		public Matrix World
		{
			get { return _world; }
			set
			{
				_world = value;
				_dirtyConstantBuffer2 = true;
			}
		}

		public TextureBinding<CubeMap> SphereTexture { get; set; }

		private unsafe void Bind()
		{
			if (_dirtyConstantBuffer2)
			{
				ConstantBuffer2 data = new ConstantBuffer2();
				data.World = World;

				_dirtyConstantBuffer2 = false;
				Update(_constantBuffer2, &data);
			}

			Bind(SphereTexture, 0);
			Bind(_constantBuffer2);
		}

		[StructLayout(LayoutKind.Sequential, Size = 64)]
		private struct ConstantBuffer2
		{
			public Matrix World;
		}
	}
}

namespace Lwar.Assets.Effects
{
	public sealed class SpriteEffect : Effect
	{
		private bool _dirtyConstantBuffer2 = true;

		private readonly ConstantBuffer _constantBuffer2;

		private Matrix _world;

		private readonly VertexShader _vertexShader;
		private readonly FragmentShader _fragmentShader;

		public SpriteEffect(GraphicsDevice graphicsDevice, AssetsManager assets)
		{
			Assert.ArgumentNotNull(graphicsDevice, () => graphicsDevice);
			Assert.ArgumentNotNull(assets, () => assets);

			_vertexShader = LoadVertexShader(assets, "Effects/Lwar.Assets.Effects.SpriteEffect.VertexShader");
			_fragmentShader = LoadFragmentShader(assets, "Effects/Lwar.Assets.Effects.SpriteEffect.FragmentShader");

			_constantBuffer2 = CreateConstantBuffer(graphicsDevice, 64, 2);
		}

		public Matrix World
		{
			get { return _world; }
			set
			{
				_world = value;
				_dirtyConstantBuffer2 = true;
			}
		}

		public TextureBinding<Texture2D> Sprite { get; set; }

		private unsafe void Bind()
		{
			if (_dirtyConstantBuffer2)
			{
				ConstantBuffer2 data = new ConstantBuffer2();
				data.World = World;

				_dirtyConstantBuffer2 = false;
				Update(_constantBuffer2, &data);
			}

			Bind(Sprite, 0);
			Bind(_constantBuffer2);
		}

		[StructLayout(LayoutKind.Sequential, Size = 64)]
		private struct ConstantBuffer2
		{
			public Matrix World;
		}
	}
}

namespace Lwar.Assets.Effects
{
	public sealed class SunEffect : Effect
	{
		private bool _dirtyConstantBuffer2 = true;

		private readonly ConstantBuffer _constantBuffer2;

		private Matrix _rotation1;
		private Matrix _rotation2;
		private Matrix _world;

		private readonly VertexShader _vertexShader;
		private readonly FragmentShader _fragmentShader;

		public SunEffect(GraphicsDevice graphicsDevice, AssetsManager assets)
		{
			Assert.ArgumentNotNull(graphicsDevice, () => graphicsDevice);
			Assert.ArgumentNotNull(assets, () => assets);

			_vertexShader = LoadVertexShader(assets, "Effects/Lwar.Assets.Effects.SunEffect.VertexShader");
			_fragmentShader = LoadFragmentShader(assets, "Effects/Lwar.Assets.Effects.SunEffect.FragmentShader");

			_constantBuffer2 = CreateConstantBuffer(graphicsDevice, 192, 2);
		}

		public Matrix Rotation1
		{
			get { return _rotation1; }
			set
			{
				_rotation1 = value;
				_dirtyConstantBuffer2 = true;
			}
		}

		public Matrix Rotation2
		{
			get { return _rotation2; }
			set
			{
				_rotation2 = value;
				_dirtyConstantBuffer2 = true;
			}
		}

		public Matrix World
		{
			get { return _world; }
			set
			{
				_world = value;
				_dirtyConstantBuffer2 = true;
			}
		}

		public TextureBinding<CubeMap> CubeMap { get; set; }
		public TextureBinding<Texture2D> HeatMap { get; set; }

		private unsafe void Bind()
		{
			if (_dirtyConstantBuffer2)
			{
				ConstantBuffer2 data = new ConstantBuffer2();
				data.Rotation1 = Rotation1;
				data.Rotation2 = Rotation2;
				data.World = World;

				_dirtyConstantBuffer2 = false;
				Update(_constantBuffer2, &data);
			}

			Bind(CubeMap, 0);
			Bind(HeatMap, 1);
			Bind(_constantBuffer2);
		}

		[StructLayout(LayoutKind.Sequential, Size = 192)]
		private struct ConstantBuffer2
		{
			public Matrix Rotation1;
			public Matrix Rotation2;
			public Matrix World;
		}
	}
}

namespace Lwar.Assets.Effects
{
	public sealed class TexturedQuadEffect : Effect
	{
		private bool _dirtyConstantBuffer2 = true;

		private readonly ConstantBuffer _constantBuffer2;

		private Matrix _world;

		private readonly VertexShader _vertexShader;
		private readonly FragmentShader _fragmentShader;

		public TexturedQuadEffect(GraphicsDevice graphicsDevice, AssetsManager assets)
		{
			Assert.ArgumentNotNull(graphicsDevice, () => graphicsDevice);
			Assert.ArgumentNotNull(assets, () => assets);

			_vertexShader = LoadVertexShader(assets, "Effects/Lwar.Assets.Effects.TexturedQuadEffect.VertexShader");
			_fragmentShader = LoadFragmentShader(assets, "Effects/Lwar.Assets.Effects.TexturedQuadEffect.FragmentShader");

			_constantBuffer2 = CreateConstantBuffer(graphicsDevice, 64, 2);
		}

		public Matrix World
		{
			get { return _world; }
			set
			{
				_world = value;
				_dirtyConstantBuffer2 = true;
			}
		}

		public TextureBinding<Texture2D> Texture { get; set; }

		private unsafe void Bind()
		{
			if (_dirtyConstantBuffer2)
			{
				ConstantBuffer2 data = new ConstantBuffer2();
				data.World = World;

				_dirtyConstantBuffer2 = false;
				Update(_constantBuffer2, &data);
			}

			Bind(Texture, 0);
			Bind(_constantBuffer2);
		}

		[StructLayout(LayoutKind.Sequential, Size = 64)]
		private struct ConstantBuffer2
		{
			public Matrix World;
		}
	}
}

