//------------------------------------------------------------------------------
// <auto-generated>
//     Generated by the Pegasus Asset Compiler.
//     Monday, 01 April 2013, 20:06:53
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Runtime.InteropServices;
using Pegasus.Framework;
using Pegasus.Framework.Math;
using Pegasus.Framework.Platform.Assets;
using Pegasus.Framework.Platform.Graphics;

namespace Lwar.Assets.Effects
{
	/// <summary>
	///   Applies a Gaussian blur filter to a texture.
	/// </summary>
	public sealed class BlurEffect : Effect
	{
		private readonly VertexShader _vertexShader;
		private readonly FragmentShader _horizontalBlur;
		private readonly FragmentShader _verticalBlur;

		/// <summary>
		///   Initializes a new instance.
		/// </summary>
		/// <param name="graphicsDevice">The graphics device this instance belongs to.</param>
		/// <param name="assets">The assets manager that should be used to load required assets.</param>
		public BlurEffect(GraphicsDevice graphicsDevice, AssetsManager assets)
			: base(graphicsDevice)
		{
			Assert.ArgumentNotNull(graphicsDevice, () => graphicsDevice);
			Assert.ArgumentNotNull(assets, () => assets);

			_vertexShader = LoadVertexShader(assets, "Effects/Lwar.Assets.Effects.BlurEffect.VertexShader");
			_horizontalBlur = LoadFragmentShader(assets, "Effects/Lwar.Assets.Effects.BlurEffect.HorizontalBlur");
			_verticalBlur = LoadFragmentShader(assets, "Effects/Lwar.Assets.Effects.BlurEffect.VerticalBlur");
		}

		/// <summary>
		///   The texture that is blurred.
		/// </summary>
		public TextureBinding<Texture2D> Texture { get; set; }

		/// <summary>
		///   Applies a horizontal Gaussian blur filter.
		/// </summary>
		public EffectTechnique BlurHorizontally
		{
			get
			{
				Bind();
				return CreateTechnique(_vertexShader, _horizontalBlur);
			}
		}

		/// <summary>
		///   Applies a vertical Gaussian blur filter.
		/// </summary>
		public EffectTechnique BlurVertically
		{
			get
			{
				Bind();
				return CreateTechnique(_vertexShader, _verticalBlur);
			}
		}

		/// <summary>
		///   Binds all textures and non-shared constant buffers required by the effect.
		/// </summary>
		private void Bind()
		{
			Bind(Texture, 0);
		}

		/// <summary>
		///   Disposes the object, releasing all managed and unmanaged resources.
		/// </summary>
		protected override void OnDisposing()
		{
			// Nothing to do here
		}
	}
}

namespace Lwar.Assets.Effects
{
	public sealed class SkyboxEffect : Effect
	{
		private readonly VertexShader _vertexShader;
		private readonly FragmentShader _fragmentShader;

		/// <summary>
		///   Initializes a new instance.
		/// </summary>
		/// <param name="graphicsDevice">The graphics device this instance belongs to.</param>
		/// <param name="assets">The assets manager that should be used to load required assets.</param>
		public SkyboxEffect(GraphicsDevice graphicsDevice, AssetsManager assets)
			: base(graphicsDevice)
		{
			Assert.ArgumentNotNull(graphicsDevice, () => graphicsDevice);
			Assert.ArgumentNotNull(assets, () => assets);

			_vertexShader = LoadVertexShader(assets, "Effects/Lwar.Assets.Effects.SkyboxEffect.VertexShader");
			_fragmentShader = LoadFragmentShader(assets, "Effects/Lwar.Assets.Effects.SkyboxEffect.FragmentShader");
		}

		public TextureBinding<CubeMap> Skybox { get; set; }

		public EffectTechnique DrawSkybox
		{
			get
			{
				Bind();
				return CreateTechnique(_vertexShader, _fragmentShader);
			}
		}

		/// <summary>
		///   Binds all textures and non-shared constant buffers required by the effect.
		/// </summary>
		private void Bind()
		{
			Bind(Skybox, 0);
		}

		/// <summary>
		///   Disposes the object, releasing all managed and unmanaged resources.
		/// </summary>
		protected override void OnDisposing()
		{
			// Nothing to do here
		}
	}
}

namespace Lwar.Assets.Effects
{
	public sealed class SphereEffect : Effect
	{
		private bool _dirtyConstantBuffer2 = true;

		private readonly ConstantBuffer _constantBuffer2;

		private Matrix _world;

		private readonly VertexShader _vertexShader;
		private readonly FragmentShader _fragmentShader;

		/// <summary>
		///   Initializes a new instance.
		/// </summary>
		/// <param name="graphicsDevice">The graphics device this instance belongs to.</param>
		/// <param name="assets">The assets manager that should be used to load required assets.</param>
		public SphereEffect(GraphicsDevice graphicsDevice, AssetsManager assets)
			: base(graphicsDevice)
		{
			Assert.ArgumentNotNull(graphicsDevice, () => graphicsDevice);
			Assert.ArgumentNotNull(assets, () => assets);

			_vertexShader = LoadVertexShader(assets, "Effects/Lwar.Assets.Effects.SphereEffect.VertexShader");
			_fragmentShader = LoadFragmentShader(assets, "Effects/Lwar.Assets.Effects.SphereEffect.FragmentShader");

			_constantBuffer2 = CreateConstantBuffer(graphicsDevice, 64, 2);
		}

		public Matrix World
		{
			get { return _world; }
			set
			{
				_world = value;
				_dirtyConstantBuffer2 = true;
			}
		}

		public TextureBinding<CubeMap> SphereTexture { get; set; }

		public EffectTechnique DrawSphere
		{
			get
			{
				Bind();
				return CreateTechnique(_vertexShader, _fragmentShader);
			}
		}

		/// <summary>
		///   Binds all textures and non-shared constant buffers required by the effect.
		/// </summary>
		private unsafe void Bind()
		{
			if (_dirtyConstantBuffer2)
			{
				ConstantBuffer2 data = new ConstantBuffer2();
				data.World = World;

				_dirtyConstantBuffer2 = false;
				Update(_constantBuffer2, &data);
			}

			Bind(SphereTexture, 0);
			Bind(_constantBuffer2);
		}

		/// <summary>
		///   Disposes the object, releasing all managed and unmanaged resources.
		/// </summary>
		protected override void OnDisposing()
		{
			_constantBuffer2.SafeDispose();
		}

		[StructLayout(LayoutKind.Sequential, Size = 64)]
		private struct ConstantBuffer2
		{
			public Matrix World;
		}
	}
}

namespace Lwar.Assets.Effects
{
	public sealed class SpriteEffect : Effect
	{
		private bool _dirtyConstantBuffer2 = true;

		private readonly ConstantBuffer _constantBuffer2;

		private Matrix _world;

		private readonly VertexShader _vertexShader;
		private readonly FragmentShader _fragmentShader;

		/// <summary>
		///   Initializes a new instance.
		/// </summary>
		/// <param name="graphicsDevice">The graphics device this instance belongs to.</param>
		/// <param name="assets">The assets manager that should be used to load required assets.</param>
		public SpriteEffect(GraphicsDevice graphicsDevice, AssetsManager assets)
			: base(graphicsDevice)
		{
			Assert.ArgumentNotNull(graphicsDevice, () => graphicsDevice);
			Assert.ArgumentNotNull(assets, () => assets);

			_vertexShader = LoadVertexShader(assets, "Effects/Lwar.Assets.Effects.SpriteEffect.VertexShader");
			_fragmentShader = LoadFragmentShader(assets, "Effects/Lwar.Assets.Effects.SpriteEffect.FragmentShader");

			_constantBuffer2 = CreateConstantBuffer(graphicsDevice, 64, 2);
		}

		public Matrix World
		{
			get { return _world; }
			set
			{
				_world = value;
				_dirtyConstantBuffer2 = true;
			}
		}

		public TextureBinding<Texture2D> Sprite { get; set; }

		public EffectTechnique DrawSprite
		{
			get
			{
				Bind();
				return CreateTechnique(_vertexShader, _fragmentShader);
			}
		}

		/// <summary>
		///   Binds all textures and non-shared constant buffers required by the effect.
		/// </summary>
		private unsafe void Bind()
		{
			if (_dirtyConstantBuffer2)
			{
				ConstantBuffer2 data = new ConstantBuffer2();
				data.World = World;

				_dirtyConstantBuffer2 = false;
				Update(_constantBuffer2, &data);
			}

			Bind(Sprite, 0);
			Bind(_constantBuffer2);
		}

		/// <summary>
		///   Disposes the object, releasing all managed and unmanaged resources.
		/// </summary>
		protected override void OnDisposing()
		{
			_constantBuffer2.SafeDispose();
		}

		[StructLayout(LayoutKind.Sequential, Size = 64)]
		private struct ConstantBuffer2
		{
			public Matrix World;
		}
	}
}

namespace Lwar.Assets.Effects
{
	public sealed class SunEffect : Effect
	{
		private bool _dirtyConstantBuffer2 = true;

		private readonly ConstantBuffer _constantBuffer2;

		private Matrix _rotation1;
		private Matrix _rotation2;
		private Matrix _world;

		private readonly VertexShader _vertexShader;
		private readonly FragmentShader _fragmentShader;

		/// <summary>
		///   Initializes a new instance.
		/// </summary>
		/// <param name="graphicsDevice">The graphics device this instance belongs to.</param>
		/// <param name="assets">The assets manager that should be used to load required assets.</param>
		public SunEffect(GraphicsDevice graphicsDevice, AssetsManager assets)
			: base(graphicsDevice)
		{
			Assert.ArgumentNotNull(graphicsDevice, () => graphicsDevice);
			Assert.ArgumentNotNull(assets, () => assets);

			_vertexShader = LoadVertexShader(assets, "Effects/Lwar.Assets.Effects.SunEffect.VertexShader");
			_fragmentShader = LoadFragmentShader(assets, "Effects/Lwar.Assets.Effects.SunEffect.FragmentShader");

			_constantBuffer2 = CreateConstantBuffer(graphicsDevice, 192, 2);
		}

		public Matrix Rotation1
		{
			get { return _rotation1; }
			set
			{
				_rotation1 = value;
				_dirtyConstantBuffer2 = true;
			}
		}

		public Matrix Rotation2
		{
			get { return _rotation2; }
			set
			{
				_rotation2 = value;
				_dirtyConstantBuffer2 = true;
			}
		}

		public Matrix World
		{
			get { return _world; }
			set
			{
				_world = value;
				_dirtyConstantBuffer2 = true;
			}
		}

		public TextureBinding<CubeMap> CubeMap { get; set; }
		public TextureBinding<Texture2D> HeatMap { get; set; }

		public EffectTechnique DrawSun
		{
			get
			{
				Bind();
				return CreateTechnique(_vertexShader, _fragmentShader);
			}
		}

		/// <summary>
		///   Binds all textures and non-shared constant buffers required by the effect.
		/// </summary>
		private unsafe void Bind()
		{
			if (_dirtyConstantBuffer2)
			{
				ConstantBuffer2 data = new ConstantBuffer2();
				data.Rotation1 = Rotation1;
				data.Rotation2 = Rotation2;
				data.World = World;

				_dirtyConstantBuffer2 = false;
				Update(_constantBuffer2, &data);
			}

			Bind(CubeMap, 0);
			Bind(HeatMap, 1);
			Bind(_constantBuffer2);
		}

		/// <summary>
		///   Disposes the object, releasing all managed and unmanaged resources.
		/// </summary>
		protected override void OnDisposing()
		{
			_constantBuffer2.SafeDispose();
		}

		[StructLayout(LayoutKind.Sequential, Size = 192)]
		private struct ConstantBuffer2
		{
			public Matrix Rotation1;
			public Matrix Rotation2;
			public Matrix World;
		}
	}
}

namespace Lwar.Assets.Effects
{
	public sealed class TexturedQuadEffect : Effect
	{
		private bool _dirtyConstantBuffer2 = true;

		private readonly ConstantBuffer _constantBuffer2;

		private Matrix _world;

		private readonly VertexShader _vertexShader;
		private readonly FragmentShader _fragmentShader;

		/// <summary>
		///   Initializes a new instance.
		/// </summary>
		/// <param name="graphicsDevice">The graphics device this instance belongs to.</param>
		/// <param name="assets">The assets manager that should be used to load required assets.</param>
		public TexturedQuadEffect(GraphicsDevice graphicsDevice, AssetsManager assets)
			: base(graphicsDevice)
		{
			Assert.ArgumentNotNull(graphicsDevice, () => graphicsDevice);
			Assert.ArgumentNotNull(assets, () => assets);

			_vertexShader = LoadVertexShader(assets, "Effects/Lwar.Assets.Effects.TexturedQuadEffect.VertexShader");
			_fragmentShader = LoadFragmentShader(assets, "Effects/Lwar.Assets.Effects.TexturedQuadEffect.FragmentShader");

			_constantBuffer2 = CreateConstantBuffer(graphicsDevice, 64, 2);
		}

		public Matrix World
		{
			get { return _world; }
			set
			{
				_world = value;
				_dirtyConstantBuffer2 = true;
			}
		}

		public TextureBinding<Texture2D> Texture { get; set; }

		public EffectTechnique DrawQuad
		{
			get
			{
				Bind();
				return CreateTechnique(_vertexShader, _fragmentShader);
			}
		}

		/// <summary>
		///   Binds all textures and non-shared constant buffers required by the effect.
		/// </summary>
		private unsafe void Bind()
		{
			if (_dirtyConstantBuffer2)
			{
				ConstantBuffer2 data = new ConstantBuffer2();
				data.World = World;

				_dirtyConstantBuffer2 = false;
				Update(_constantBuffer2, &data);
			}

			Bind(Texture, 0);
			Bind(_constantBuffer2);
		}

		/// <summary>
		///   Disposes the object, releasing all managed and unmanaged resources.
		/// </summary>
		protected override void OnDisposing()
		{
			_constantBuffer2.SafeDispose();
		}

		[StructLayout(LayoutKind.Sequential, Size = 64)]
		private struct ConstantBuffer2
		{
			public Matrix World;
		}
	}
}

