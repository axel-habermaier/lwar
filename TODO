Client
========
- Effects
	- Improve planet rendering
	- Nebulae
	- Improve shield effect
	- Weapon effects
	- Particle system
	- Move skybox
- Entity interpolation
	- Reusable interpolation class?
- UI
	- Ship/Weapon selection
	- Minimap
	- Menus
		* Main menu
		* Server browser
		* Configuration (graphics settings, input settings, ...)
- Camera zoom bug in very-low FPS situations
- Multiple player names might overlap
- Let camera follow ship (sort of: attach the camera to the ship with a spring)
- Show server network statistics
- Collect and show client network statistics (avg number of times a reliable message was sent/received, # of incoming packets per second, etc.)
- Implement relative mouse coordinates

Pegasus.Framework
========
- Show platform statistics, add 'level of detail' to show_stats cvar
- Fully implement emoticon support
- Track fullscreen resolution changes and add standard timeout-and-reset functionality for invalid resolutions
- Key down/up in the same frame, multiple key down/ups in same frame
- Persist key bindings
- Use triple buffering for dynamic vertex buffers (sprite batch) 
- Sprite batch should not force-draw when changing the world matrix, blend state, etc.; instead, a new section should be started

Pegasus.Platform
========
- Linux: Enforce minimum/maximum allowed window size (use XSetWMNormalHints)
- Linux: Double clicking not implemented
- Linux: Fullscreen not implemented, moving and resizing window mostly not working
- Linux: Input bug (for instance, crash when entering text into the console; dead key problem -> use previously used deprecated function?)
- Statistics: # of draw calls, # of (redundant) state changes, # of textures, etc.
- Bug: Window is not opened in maximized mode when native debugging is not enabled??
- Add sync/fence objects
- Allow binding of multiple constant buffers at once?

Assets Compiler
========
- Storing cubemaps as 6 separate images might improve compilation times noticably
- Add dependency system (e.g., cubemap depends on 6 textures, font depends on texture)
- Asset compression
	- Store all assets in one or more .zip-files
	- Give higher priorities to files on the filesystem (similar to Quake 3)
- Fix constant buffer packing
- Technique should check whether shader signatures match
- Add Misc() semantics

Network
========
- Send network spec revision number with Connect message, send WrongVersion message on version mismatch
- Are all reliable messages sent multiple times before there's even a chance to acknowledge them? Is that a problem?
  Comment: queue.c last_tx_time and RETRANSMIT_INTERVAL capture this, see qm_check_relevant
- Should collision messages be reliable? Otherwise the client has to filter collision messages...

Server
========
- !!mouse aim bug
- !!collisions with planets and intersection of entities should destroy them
- !!Level boundaries
- !!respawn: maybe just after some click?
- !!strafing
- !Level Design
- slots need relative placement wrt ship,
  extend entity type struct for this
- server: copy string to player, free memory
- figure out how to communicate ammount of ammunition
- Check assertion problem in player.c:85
- Fix infinite ship duplication bug (might be a client issue?)


Some notes...
=================================================================

// Handle double click timing
	if (event.type == ButtonPress)
	{
		Time time_change = event.time - time_at_last_press;
		time_at_last_press = event.time;

		if (last_press_id == id)	// Same key pressed
		{
			if (time_change < 500)	// 500 ms is the default in Windows
			{
				is_a_double_click_event = true;
				last_press_id = -1;	// Reset to avoid "tripple clicks"
			}
		}
		else
		{
			last_press_id = id;
		}
	}
	
	
	
void X11Window::clear_structurenotify_events()
{
	XEvent event;
	while( XCheckMaskEvent(display, StructureNotifyMask, &event));

}
	
	void X11Window::map_window()
{
	clear_structurenotify_events();

	if (!is_window_mapped)
	{
		int result = XMapWindow(display, window);
		if ( (result == BadValue) || (result == BadWindow) )
		{
			throw Exception("Failed to map window");		
		}
		else
		{
			XEvent event;
			do {
				XWindowEvent(display, window, StructureNotifyMask, &event);
			}while ( event.type != MapNotify );

			is_window_mapped = true;

			if (fullscreen)
				XSetInputFocus(display, window, RevertToParent, CurrentTime);
		}

		if (!frame_size_calculated)
		{
			frame_size_calculated = true;
			calculate_window_frame_size();

			if (!fullscreen)
			{
				// Now we know the frame size, nudge the window into the exact position
				Rect frame_size = requested_current_window_client_area;	// Must copy as set_position() changes this variable, causing all sorts of problems
				set_position(frame_size, !requested_size_contains_frame);
			}
			current_window_client_area = get_screen_position();
			requested_current_window_client_area = current_window_client_area;
		}

		always_send_window_position_changed_event = true;
		always_send_window_size_changed_event = true;
	}
}

void X11Window::unmap_window()
{
	clear_structurenotify_events();
	if (is_window_mapped)
	{
		int result = XUnmapWindow(display, window);
		if ( (result == BadValue) || (result == BadWindow) )
		{
			throw Exception("Failed to unmap window");		
		}
		else
		{
			XEvent event;
			do {
				XWindowEvent(display, window, StructureNotifyMask, &event);
			}while (event.type != UnmapNotify);

			is_window_mapped = false;
		}
	}
}