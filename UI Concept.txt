Use VS+Blend to design UI with XAML/WPF
Asset Compiler: Convert XAML files to equivalent C# code that is included by lwar
	-> automatically compiles required image resources and fonts
	-> requires interfaces for all DataContexts
	-> Bindings, etc. use Func<obj,T>s + casting instead of reflection/dynamic
	-> Copy all value converters, XAML code-behind, etc. to generated output 
	-> or use T4 templates to compile XAML files (similar to cvar/command registries?); UI cannot be reloaded at runtime anyway
Framework implements parts of WPF's object model

WPF Object model (required parts):
- Dependency/Attached Properties
- Routed/Attached Events
- Controls
	* Window
	* TextBox 
	* Scrollviewer
	* Label
	* Combobox (side-way scrolling)
	* Checkbox
	* Button
	* Image
	* 3D scene (allows arbitrary rendering)
	* ItemsControl
- Layouting: Arrange & Measure
	* StackPanel
	* Canvas
	* DockPanel
- Animation system
- Styles (no themes/default styles)
- Templates
- Data binding/DataContext with type-safe view models
- UI Drawing with IRTs for (semi-)transparent or 3D-transformed elements

Open questions
- How do dependency properties/routed events work?
	* DP: Globally unique id
		- DP values store: current animated value, local value, expression value
		- When inheritance: walk the tree (expensive); DO knows its ancestors
		- Default value: Get from DP instance
		- SetValue(value, origin) with origin = Animation, Local, etc.
		- Local value is either true local value or style value or style trigger value, etc. because true local values override style values anyway
			* What about style triggers whose effects need to be undone?
		- ClearValue() analogous
		- Animation: SetValue, call ClearValue() on end
		- Trigger: SetValue() when active, ClearValue() when inactive
		- For triggers and animations: order of declaration is important (last trigger overrides all previous ones if the same DP is set)
		- For all triggers of a style/template: Determine activated/deactivated ones
			If there was a change:
				1. Call ClearValue for all trigger setters of the deactivate triggers 
				2. Call SetValue for all trigger setter of the activated triggers
				3. execute exit actions of all deactivated triggers
				4. execute all entry actions of all activated triggers
	* DO: Array of DP values (binding, value, animated value), sorted by DP.id, using binary search to find DP
- How deas Measure & Arrange work?
- How does input handling work?
- How does drawing work?
	* http://msdn.microsoft.com/en-us/library/ms748373.aspx
	* Generate list of drawning commands - which can be cached as long as nothing changes
- How does data binding work 
	* Source expression: must be able to cope with dep props/regular props, etc.
	* source expr must react to all changes in the property path
	* GetSourceValue, SetSourceValue, GetTargetValue, SetTargetValue actions with closures
	* Just execute every frame to see if value changed (no PropertyChanged events!), use SetValue(v, Local) to set DP value
		Or: set expression as local value on DP, evaluate only when whenever local value is required
	* If no binding source is specified, bind to DataContext property of the object that is bound as the target
- Hierarchy of resource dictionaries
	* Static binding - simple lookup at initialization time
		-> walk up the tree until a resource with a matching key is found
		only one key per dictionary; key might be overriden in lower layers; merged dictionaries with equal keys: last one wins
	* Dynamic resource: Expression set on DP, does lookup when whenever local value is required
- Each frame:
	1. Do input
	2. update bindings
	3. Check style/template triggers
	4. Do animations
	5. update layout
	6. render